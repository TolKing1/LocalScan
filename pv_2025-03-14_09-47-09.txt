# C:\Projects\local\mod-password-validator\src\main\java\org\folio\pv\client\HashedPasswordUsageCollectionConverter.java

package org.folio.pv.client;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import lombok.extern.log4j.Log4j2;
import org.folio.pv.domain.dto.HashedPasswordUsage;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpInputMessage;
import org.springframework.http.HttpOutputMessage;
import org.springframework.http.MediaType;
import org.springframework.http.converter.AbstractGenericHttpMessageConverter;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.http.converter.HttpMessageNotWritableException;
import org.springframework.lang.Nullable;
import org.springframework.util.ReflectionUtils;

@Log4j2
public class HashedPasswordUsageCollectionConverter<T extends Collection<HashedPasswordUsage>>
  extends AbstractGenericHttpMessageConverter<T> {

  private static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8;
  private static final String INSTANTIATED_ERROR = "Could not instantiate collection class: %s";
  private static final String INVALID_FORMAT_ERROR = "[line: %s ] Invalid format of the line: '%s'";

  private final Pattern usagePattern = Pattern.compile("\\s*([0-9a-fA-F]+)\\s*:\\s*(\\d+)\\s*");

  public HashedPasswordUsageCollectionConverter() {
    super(MediaType.TEXT_PLAIN);
  }

  @Override
  public boolean canRead(Class<?> clazz, @Nullable MediaType mediaType) {
    return false;
  }

  @Override
  public boolean canRead(Type type, Class<?> contextClass, MediaType mediaType) {
    if (!(type instanceof ParameterizedType)) {
      return false;
    }

    ParameterizedType parameterizedType = (ParameterizedType) type;
    if (!(parameterizedType.getRawType() instanceof Class)) {
      return false;
    }

    Class<?> rawType = (Class<?>) parameterizedType.getRawType();
    if (!(Collection.class.isAssignableFrom(rawType))) {
      return false;
    }

    if (parameterizedType.getActualTypeArguments().length != 1) {
      return false;
    }

    Type typeArgument = parameterizedType.getActualTypeArguments()[0];
    if (!(typeArgument instanceof Class)) {
      return false;
    }

    Class<?> typeArgumentClass = (Class<?>) typeArgument;
    return HashedPasswordUsage.class.isAssignableFrom(typeArgumentClass) && canRead(mediaType);
  }

  @Override
  public boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType) {
    return false;
  }

  @Override
  public boolean canWrite(@Nullable Type type, @Nullable Class<?> clazz, @Nullable MediaType mediaType) {
    return false;
  }

  @Override
  public T read(Type type, Class<?> contextClass, HttpInputMessage inputMessage)
    throws IOException, HttpMessageNotReadableException {

    ParameterizedType parameterizedType = (ParameterizedType) type;
    T result = createCollection((Class<?>) parameterizedType.getRawType());

    try (BufferedReader reader = getReader(inputMessage)) {
      String line;
      int ln = 0;

      while ((line = reader.readLine()) != null) {
        result.add(parseUsage(line, ln, inputMessage));
        ln++;
      }
    }

    log.debug("Total number of hashed password usages extracted from the input: " + result.size());

    return result;
  }

  @Override
  protected boolean supports(Class<?> clazz) {
    return false;
  }

  @Override
  protected void writeInternal(T hashedPasswordUsages, Type type,
                               HttpOutputMessage outputMessage) throws HttpMessageNotWritableException {
    throw new UnsupportedOperationException();
  }

  @Override
  protected T readInternal(Class<? extends T> clazz, HttpInputMessage inputMessage)
    throws HttpMessageNotReadableException {
    throw new UnsupportedOperationException();
  }

  private HashedPasswordUsage parseUsage(String line, int lineNumber, HttpInputMessage inputMessage) {
    Matcher m = usagePattern.matcher(line);

    if (m.matches()) {
      String suffix = m.group(1);
      int usageCount = Integer.parseInt(m.group(2));
      return new HashedPasswordUsage(suffix, usageCount);
    } else {
      var errorMessage = String.format(INVALID_FORMAT_ERROR, lineNumber, line);
      log.warn(errorMessage);
      throw new HttpMessageNotReadableException(errorMessage, inputMessage);
    }
  }

  @SuppressWarnings("unchecked")
  private T createCollection(Class<?> collectionClass) {
    if (!collectionClass.isInterface()) {
      try {
        return (T) ReflectionUtils.accessibleConstructor(collectionClass).newInstance();
      } catch (Exception ex) {
        var errorMessage = String.format(INSTANTIATED_ERROR, collectionClass.getName());
        log.warn(errorMessage);
        throw new IllegalArgumentException(errorMessage, ex);
      }
    } else if (List.class == collectionClass) {
      return (T) new ArrayList<HashedPasswordUsage>();
    } else if (SortedSet.class == collectionClass) {
      return (T) new TreeSet<HashedPasswordUsage>();
    } else {
      return (T) new LinkedHashSet<HashedPasswordUsage>();
    }
  }

  private static BufferedReader getReader(HttpInputMessage inputMessage) throws IOException {
    return new BufferedReader(new InputStreamReader(inputMessage.getBody(), getCharset(inputMessage.getHeaders())));
  }

  private static Charset getCharset(HttpHeaders headers) {
    var contentType = headers.getContentType();
    var charset = contentType != null ? contentType.getCharset() : null;
    return charset != null ? charset : DEFAULT_CHARSET;
  }
}


# C:\Projects\local\mod-password-validator\src\main\java\org\folio\pv\client\PwnedClient.java

package org.folio.pv.client;

import java.util.List;
import org.folio.pv.domain.dto.HashedPasswordUsage;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

@FeignClient(name = "pwned-passwords",
  url = "${pwned-passwords.client.url}",
  configuration = PwnedClientConfiguration.class)
public interface PwnedClient {

  @GetMapping(path = "/range/{hashPrefix}", produces = MediaType.TEXT_PLAIN_VALUE)
  List<HashedPasswordUsage> getPwdRange(@PathVariable String hashPrefix);

}


# C:\Projects\local\mod-password-validator\src\main\java\org\folio\pv\client\PwnedClientAddPaddingInterceptor.java

package org.folio.pv.client;

import feign.RequestInterceptor;
import feign.RequestTemplate;

public class PwnedClientAddPaddingInterceptor implements RequestInterceptor {

  private static final String ADD_PADDING_HEADER = "Add-Padding";

  private final boolean paddingEnabled;


  public PwnedClientAddPaddingInterceptor(boolean paddingEnabled) {
    this.paddingEnabled = paddingEnabled;
  }

  @Override
  public void apply(RequestTemplate template) {
    if (paddingEnabled) {
      template.header(ADD_PADDING_HEADER, "true");
    }
  }
}


# C:\Projects\local\mod-password-validator\src\main\java\org\folio\pv\client\PwnedClientConfiguration.java

package org.folio.pv.client;

import feign.Client;
import feign.RequestInterceptor;
import feign.codec.Decoder;
import feign.okhttp.OkHttpClient;
import java.util.ArrayList;
import org.springframework.beans.factory.ObjectFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.http.HttpMessageConverters;
import org.springframework.cloud.openfeign.support.SpringDecoder;
import org.springframework.context.annotation.Bean;
import org.springframework.http.converter.HttpMessageConverter;

public class PwnedClientConfiguration {

  @Autowired
  private ObjectFactory<HttpMessageConverters> messageConverters;

  @Bean
  public Client feignClient(okhttp3.OkHttpClient okHttpClient) {
    return new OkHttpClient(okHttpClient);
  }

  @Bean
  public Decoder feignDecoder() {
    var springConverters = messageConverters.getObject().getConverters();
    var decoderConverters = new ArrayList<HttpMessageConverter<?>>(springConverters.size() + 1);

    decoderConverters.addAll(springConverters);
    decoderConverters.add(new HashedPasswordUsageCollectionConverter<>());

    var httpMessageConverters = new HttpMessageConverters(decoderConverters);

    return new SpringDecoder(() -> httpMessageConverters);
  }

  @Bean
  public RequestInterceptor addPaddingInterceptor(
    @Value("${pwned-passwords.padding.enabled}") boolean paddingEnabled) {
    return new PwnedClientAddPaddingInterceptor(paddingEnabled);
  }

}


# C:\Projects\local\mod-password-validator\src\main\java\org\folio\pv\client\UserClient.java

package org.folio.pv.client;

import java.util.Optional;
import lombok.Value;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

@FeignClient("users")
public interface UserClient {

  @GetMapping(value = "/{id}", produces = MediaType.APPLICATION_JSON_VALUE)
  Optional<UserDto> getUserById(@PathVariable("id") String id);

  @Value
  class UserDto {

    String id;
    String username;
  }
}


# C:\Projects\local\mod-password-validator\src\main\java\org\folio\pv\config\ModPasswordValidatorSpringConfiguration.java

package org.folio.pv.config;

import org.springframework.context.annotation.Configuration;

@Configuration
public class ModPasswordValidatorSpringConfiguration {

}


# C:\Projects\local\mod-password-validator\src\main\java\org\folio\pv\controller\ErrorHandlingController.java

package org.folio.pv.controller;

import java.util.List;
import java.util.stream.Collectors;
import org.folio.cql2pgjson.exception.CQL2PgJSONException;
import org.folio.pv.domain.dto.Error;
import org.folio.pv.domain.dto.Errors;
import org.folio.pv.domain.dto.Parameter;
import org.folio.pv.service.exception.NoRulesMatchedException;
import org.folio.pv.service.exception.UserNotFoundException;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.ResponseStatus;

@ControllerAdvice
public class ErrorHandlingController {

  private static final String USER_ID_FIELD = "userId";
  private static final String INTERNAL_ERROR_TYPE = "-1";
  private static final String FOLIO_EXTERNAL_OR_UNDEFINED_ERROR_TYPE = "-2";

  @ResponseBody
  @ResponseStatus(HttpStatus.UNPROCESSABLE_ENTITY)
  @ExceptionHandler(MethodArgumentNotValidException.class)
  public Errors handleException(MethodArgumentNotValidException exception) {
    final List<Error> errors = exception.getBindingResult().getFieldErrors().stream()
      .map(error -> {
        Parameter parameter = new Parameter()
          .key(error.getField())
          .value(String.valueOf(error.getRejectedValue()));

        return new Error().message(error.getField() + ' ' + error.getDefaultMessage())
          .addParametersItem(parameter)
          .type(INTERNAL_ERROR_TYPE);
      })
      .collect(Collectors.toList());

    return new Errors().errors(errors).totalRecords(errors.size());
  }

  @ResponseBody
  @ResponseStatus(HttpStatus.NOT_FOUND)
  @ExceptionHandler(UserNotFoundException.class)
  public Error handleException(UserNotFoundException exception) {
    Parameter parameter = new Parameter()
      .key(USER_ID_FIELD)
      .value(exception.getUserId());

    return new Error().message(exception.getMessage())
      .type(FOLIO_EXTERNAL_OR_UNDEFINED_ERROR_TYPE)
      .addParametersItem(parameter);
  }

  @ResponseBody
  @ResponseStatus(HttpStatus.UNPROCESSABLE_ENTITY)
  @ExceptionHandler(NoRulesMatchedException.class)
  public Error handleException(NoRulesMatchedException exception) {
    return new Error().message(exception.getMessage())
        .type(FOLIO_EXTERNAL_OR_UNDEFINED_ERROR_TYPE);
  }

  @ResponseBody
  @ResponseStatus(HttpStatus.UNPROCESSABLE_ENTITY)
  @ExceptionHandler(CQL2PgJSONException.class)
  public Error handleException(CQL2PgJSONException exception) {
    return new Error().message(exception.getMessage())
      .type(FOLIO_EXTERNAL_OR_UNDEFINED_ERROR_TYPE);
  }

}


# C:\Projects\local\mod-password-validator\src\main\java\org\folio\pv\controller\PasswordValidatorController.java

package org.folio.pv.controller;

import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.folio.pv.domain.dto.Password;
import org.folio.pv.domain.dto.PasswordCheck;
import org.folio.pv.domain.dto.ValidationResult;
import org.folio.pv.rest.resource.PasswordApi;
import org.folio.pv.service.PasswordValidatorService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;


@Log4j2
@RestController
@RequestMapping(value = "/")
@RequiredArgsConstructor
public class PasswordValidatorController implements PasswordApi {
  private final PasswordValidatorService passwordValidatorService;

  @Override
  public ResponseEntity<ValidationResult> validatePassword(@Valid Password password, String xOkapiTenant) {
    log.info("Validating password API");
    ValidationResult validationResult = passwordValidatorService.validatePasswordByRules(xOkapiTenant, password);
    return ResponseEntity.ok(validationResult);
  }

  @Override
  public ResponseEntity<ValidationResult> checkPassword(@Valid PasswordCheck passwordCheck, String xOkapiTenant) {
    log.info("Checking password API");
    ValidationResult validationResult = passwordValidatorService.checkPassword(xOkapiTenant, passwordCheck);
    return ResponseEntity.ok(validationResult);
  }
}


# C:\Projects\local\mod-password-validator\src\main\java\org\folio\pv\controller\ValidationRulesController.java

package org.folio.pv.controller;

import jakarta.validation.Valid;
import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Min;
import lombok.extern.log4j.Log4j2;
import org.folio.pv.domain.dto.ValidationRule;
import org.folio.pv.domain.dto.ValidationRuleCollection;
import org.folio.pv.rest.resource.RulesApi;
import org.folio.pv.service.ValidationRuleService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@Log4j2
@RestController
@RequestMapping(value = "/tenant/")
public class ValidationRulesController implements RulesApi {

  private final ValidationRuleService validationRuleService;

  @Autowired
  public ValidationRulesController(ValidationRuleService validationRuleService) {
    this.validationRuleService = validationRuleService;
  }

  @Override
  public ResponseEntity<ValidationRule> getTenantRuleById(String ruleId) {
    var rule = validationRuleService.getValidationRuleById(ruleId);
    return rule == null ? ResponseEntity.notFound().build() : new ResponseEntity<>(rule, HttpStatus.OK);
  }

  @Override
  public ResponseEntity<ValidationRuleCollection> getTenantRules(@Min(0) @Max(2147483647) @Valid Integer offset,
                                                                 @Min(0) @Max(2147483647) @Valid Integer limit,
                                                                 @Valid String cql) {
    var validationRules = validationRuleService.getValidationRules(offset, limit, cql);
    return new ResponseEntity<>(validationRules, HttpStatus.OK);
  }

  @Override
  public ResponseEntity<ValidationRule> postTenantRules(@Valid ValidationRule validationRule) {
    var rule = validationRuleService.createOrUpdateValidationRule(validationRule);
    return new ResponseEntity<>(rule, HttpStatus.OK);
  }

  @Override
  public ResponseEntity<ValidationRule> putTenantRule(@Valid ValidationRule validationRule) {
    var rule = validationRuleService.storeValidationRule(validationRule);
    return new ResponseEntity<>(rule, HttpStatus.OK);
  }
}


# C:\Projects\local\mod-password-validator\src\main\java\org\folio\pv\domain\dto\HashedPasswordUsage.java

package org.folio.pv.domain.dto;

import java.util.Comparator;
import lombok.Value;

@Value
public class HashedPasswordUsage implements Comparable<HashedPasswordUsage> {

  String suffix;
  int usageCount;

  @Override
  public int compareTo(HashedPasswordUsage o) {
    return Comparator.comparingInt(HashedPasswordUsage::getUsageCount)
      .thenComparing(HashedPasswordUsage::getSuffix)
      .compare(o, this);
  }
}


# C:\Projects\local\mod-password-validator\src\main\java\org\folio\pv\domain\dto\PasswordHash.java

package org.folio.pv.domain.dto;

import lombok.Value;
import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.lang3.StringUtils;

@Value
public class PasswordHash {

  String hash;
  String prefix;
  String suffix;

  public PasswordHash(String password) {
    hash = DigestUtils.sha1Hex(password).toUpperCase();
    prefix = StringUtils.left(hash, 5);
    suffix = hash.substring(5);
  }

}


# C:\Projects\local\mod-password-validator\src\main\java\org\folio\pv\domain\dto\UserData.java

package org.folio.pv.domain.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
public class UserData {

  String id;
  String name;

}


# C:\Projects\local\mod-password-validator\src\main\java\org\folio\pv\domain\dto\ValidationErrors.java

package org.folio.pv.domain.dto;

import static java.util.Collections.emptyList;
import static java.util.Collections.unmodifiableList;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import lombok.EqualsAndHashCode;
import lombok.ToString;

@EqualsAndHashCode
@ToString
public final class ValidationErrors {

  private static final ValidationErrors NONE = new ValidationErrors();

  private final List<String> errorMessages;

  private ValidationErrors() {
    this(emptyList());
  }

  private ValidationErrors(List<String> errorMessages) {
    this.errorMessages = errorMessages != null ? new ArrayList<>(errorMessages) : emptyList();
  }

  public static ValidationErrors none() {
    return NONE;
  }

  public static ValidationErrors of(String... messages) {
    return new ValidationErrors(Arrays.asList(messages));
  }

  public static ValidationErrors of(List<String> messages) {
    return new ValidationErrors(messages);
  }

  public boolean hasErrors() {
    return !errorMessages.isEmpty();
  }

  public List<String> getErrorMessages() {
    return unmodifiableList(errorMessages);
  }
}


# C:\Projects\local\mod-password-validator\src\main\java\org\folio\pv\domain\entity\PasswordValidationRule.java

package org.folio.pv.domain.entity;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.util.UUID;
import lombok.Data;
import org.folio.pv.domain.RuleState;
import org.folio.pv.domain.RuleType;
import org.folio.pv.domain.ValidationType;
import org.hibernate.annotations.JdbcType;
import org.hibernate.dialect.PostgreSQLEnumJdbcType;

@Data
@Table(name = "VALIDATIONRULES")
@Entity
public class PasswordValidationRule {

  @Id
  @GeneratedValue
  private UUID id;

  @Column(name = "name")
  private String name;

  @Column(name = "rule_type", columnDefinition = "RuleType")
  @Enumerated(EnumType.STRING)
  @JdbcType(PostgreSQLEnumJdbcType.class)
  private RuleType ruleType;

  @Column(name = "rule_state", columnDefinition = "RuleState")
  @Enumerated(EnumType.STRING)
  @JdbcType(PostgreSQLEnumJdbcType.class)
  private RuleState ruleState;

  @Column(name = "validation_type", columnDefinition = "RuleValidationType")
  @Enumerated(EnumType.STRING)
  @JdbcType(PostgreSQLEnumJdbcType.class)
  private ValidationType validationType;

  @Column(name = "order_no")
  private Integer orderNo;

  @Column(name = "rule_expression")
  private String ruleExpression;

  @Column(name = "implementation_reference")
  private String implementationReference;

  @Column(name = "module_name")
  private String moduleName;

  @Column(name = "description")
  private String description;

  @Column(name = "err_message_id")
  private String errMessageId;

  @Column(name = "created_date")
  private Timestamp createdDate;

  @Column(name = "updated_date")
  private Timestamp updatedDate;

  @Column(name = "created_by_user_id")
  private UUID createdByUserId;

  @Column(name = "updated_by_user_id")
  private UUID updatedByUserId;

  @Column(name = "created_by_username")
  private String createdByUsername;

  @Column(name = "updated_by_username")
  private String updatedByUsername;


  public PasswordValidationRule copyForUpdate(PasswordValidationRule another) {
    this.setRuleType(another.getRuleType());
    this.setRuleState(another.getRuleState());
    this.setValidationType(another.getValidationType());
    this.setOrderNo(another.getOrderNo());
    this.setRuleExpression(another.getRuleExpression());
    this.setImplementationReference(another.getImplementationReference());
    this.setModuleName(another.getModuleName());
    this.setDescription(another.getDescription());
    this.setErrMessageId(another.getErrMessageId());
    this.setUpdatedByUserId(another.getUpdatedByUserId());
    this.setUpdatedByUsername(another.getUpdatedByUsername());
    var ud = another.getUpdatedDate();
    this.setUpdatedDate(ud != null ? ud : Timestamp.valueOf(LocalDateTime.now()));

    return this;
  }
}


# C:\Projects\local\mod-password-validator\src\main\java\org\folio\pv\domain\RuleState.java

package org.folio.pv.domain;

public enum RuleState {

  ENABLED("Enabled"),
  DISABLED("Disabled");

  private final String value;

  RuleState(String value) {
    this.value = value;
  }

  public String getValue() {
    return value;
  }

  @Override
  public String toString() {
    return String.valueOf(value);
  }

  public static RuleState fromValue(String value) {
    for (RuleState rt : RuleState.values()) {
      if (rt.value.equals(value) || rt.value.toUpperCase().equals(value)) {
        return rt;
      }
    }
    throw new IllegalArgumentException("Unexpected value '" + value + "'");
  }
}


# C:\Projects\local\mod-password-validator\src\main\java\org\folio\pv\domain\RuleType.java

package org.folio.pv.domain;

public enum RuleType {
  REGEXP("RegExp"),
  PROGRAMMATIC("Programmatic"),
  PWNEDPASSWORD("PwnedPassword");

  private final String value;

  RuleType(String value) {
    this.value = value;
  }

  public static RuleType fromValue(String value) {
    for (RuleType rt : RuleType.values()) {
      if (rt.value.equals(value) || (rt.value.toUpperCase().equals(value))) {
        return rt;
      }
    }
    throw new IllegalArgumentException("Unexpected value '" + value + "'");
  }

  public String getValue() {
    return value;
  }

  @Override
  public String toString() {
    return String.valueOf(value);
  }
}


# C:\Projects\local\mod-password-validator\src\main\java\org\folio\pv\domain\ValidationType.java

package org.folio.pv.domain;

public enum ValidationType {
  SOFT("Soft"),
  STRONG("Strong");

  private final String value;

  ValidationType(String value) {
    this.value = value;
  }

  public String getValue() {
    return value;
  }

  @Override
  public String toString() {
    return String.valueOf(value);
  }

  public static ValidationType fromValue(String value) {
    for (ValidationType vt : ValidationType.values()) {
      if (vt.value.equals(value) || vt.value.toUpperCase().equals(value)) {
        return vt;
      }
    }
    throw new IllegalArgumentException("Unexpected value '" + value + "'");
  }
}


# C:\Projects\local\mod-password-validator\src\main\java\org\folio\pv\mapper\ValidationRuleMapper.java

package org.folio.pv.mapper;

import java.util.List;
import java.util.UUID;
import org.apache.commons.lang3.StringUtils;
import org.folio.pv.domain.RuleState;
import org.folio.pv.domain.RuleType;
import org.folio.pv.domain.ValidationType;
import org.folio.pv.domain.dto.ValidationRule;
import org.folio.pv.domain.dto.ValidationRuleCollection;
import org.folio.pv.domain.entity.PasswordValidationRule;
import org.mapstruct.InheritInverseConfiguration;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.Mappings;
import org.mapstruct.NullValueCheckStrategy;

@Mapper(componentModel = "spring",
  nullValueCheckStrategy = NullValueCheckStrategy.ALWAYS,
  imports = {RuleType.class, RuleState.class, ValidationType.class})
public interface ValidationRuleMapper {

  @Mapping(target = "id", expression = "java(uuidToStringSafe(passwordValidationRule.getId()))")
  @Mapping(target = "name", source = "name")
  @Mapping(target = "type", expression = "java(passwordValidationRule.getRuleType() != null ? "
    + "ValidationRule.TypeEnum.fromValue(passwordValidationRule.getRuleType().getValue()) : null)")
  @Mapping(target = "state", expression = "java(passwordValidationRule.getRuleState() != null ? "
    + "ValidationRule.StateEnum.fromValue(passwordValidationRule.getRuleState().getValue()) : null)")
  @Mapping(target = "validationType", expression = "java(passwordValidationRule.getValidationType() != null ? "
    + "ValidationRule.ValidationTypeEnum.fromValue(passwordValidationRule.getValidationType().getValue()) : null)")
  @Mapping(target = "moduleName", source = "moduleName")
  @Mapping(target = "implementationReference", source = "implementationReference")
  @Mapping(target = "expression", source = "ruleExpression")
  @Mapping(target = "description", source = "description")
  @Mapping(target = "orderNo", source = "orderNo")
  @Mapping(target = "errMessageId", source = "errMessageId")
  @Mapping(target = "metadata.createdDate", source = "createdDate")
  @Mapping(target = "metadata.updatedDate", source = "updatedDate")
  @Mapping(target = "metadata.createdByUserId",
    expression = "java(passwordValidationRule.getCreatedByUserId() == null ? "
      + "null : String.valueOf(passwordValidationRule.getCreatedByUserId()))")
  @Mapping(target = "metadata.updatedByUserId",
    expression = "java(passwordValidationRule.getUpdatedByUserId() == null ? "
      + "null : String.valueOf(passwordValidationRule.getUpdatedByUserId()))")
  @Mapping(target = "metadata.createdByUsername", source = "createdByUsername")
  @Mapping(target = "metadata.updatedByUsername", source = "updatedByUsername")
  ValidationRule mapEntityToDto(PasswordValidationRule passwordValidationRule);

  @Mapping(target = "id", expression = "java(stringToUuidSafe(validationRule.getId()))")
  @Mapping(target = "ruleType", expression = "java(validationRule.getType() != null ? "
    + "RuleType.fromValue(validationRule.getType().getValue()) : null)")
  @Mapping(target = "ruleState", expression = "java(validationRule.getState() != null ? "
    + "RuleState.fromValue(validationRule.getState().getValue()) : null)")
  @Mapping(target = "validationType", expression = "java(validationRule.getState() != null ? "
    + "ValidationType.fromValue(validationRule.getValidationType().getValue()) : null)")
  @Mapping(target = "createdByUserId", expression = "java(validationRule.getMetadata() == null ? "
    + "null : stringToUuidSafe(validationRule.getMetadata().getCreatedByUserId()))")
  @Mapping(target = "updatedByUserId", expression = "java(validationRule.getMetadata() == null ? "
    + "null : stringToUuidSafe(validationRule.getMetadata().getUpdatedByUserId()))")
  @InheritInverseConfiguration
  PasswordValidationRule mapDtoToEntity(ValidationRule validationRule);

  @Mappings({})
  List<ValidationRule> mapEntitiesToDtos(Iterable<PasswordValidationRule> passwordValidationRuleList);

  @InheritInverseConfiguration
  List<PasswordValidationRule> mapDtosToEntities(List<ValidationRule> validationRuleList);

  default ValidationRuleCollection mapEntitiesToValidationRuleCollection(
    Iterable<PasswordValidationRule> passwordValidationRuleList) {
    var rules = mapEntitiesToDtos(passwordValidationRuleList);
    return new ValidationRuleCollection().rules(rules).totalRecords(rules.size());
  }

  default UUID stringToUuidSafe(String uuid) {
    return (StringUtils.isBlank(uuid)) ? null : java.util.UUID.fromString(uuid);
  }

  default String uuidToStringSafe(UUID uuid) {
    return uuid != null ? uuid.toString() : null;
  }
}


# C:\Projects\local\mod-password-validator\src\main\java\org\folio\pv\ModPasswordValidatorApplication.java

package org.folio.pv;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.openfeign.EnableFeignClients;

@SpringBootApplication
@EnableFeignClients
public class ModPasswordValidatorApplication {

  public static void main(String[] args) {
    SpringApplication.run(ModPasswordValidatorApplication.class, args);
  }

}


# C:\Projects\local\mod-password-validator\src\main\java\org\folio\pv\repository\ValidationRuleRepository.java

package org.folio.pv.repository;

import java.util.List;
import java.util.UUID;
import org.folio.pv.domain.RuleState;
import org.folio.pv.domain.entity.PasswordValidationRule;
import org.folio.spring.cql.JpaCqlRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface ValidationRuleRepository extends JpaCqlRepository<PasswordValidationRule, UUID> {
  List<PasswordValidationRule> findByRuleState(RuleState ruleState);
}


# C:\Projects\local\mod-password-validator\src\main\java\org\folio\pv\service\CacheEvictionService.java

package org.folio.pv.service;

import static org.folio.pv.service.ValidationRuleServiceImpl.VALIDATION_RULES_CACHE;

import lombok.extern.log4j.Log4j2;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

@Service
@Log4j2
public class CacheEvictionService {

  @CacheEvict(value = {VALIDATION_RULES_CACHE}, allEntries = true)
  @Scheduled(
      fixedRateString = "${cache.eviction.time.validation-rule}",
      initialDelayString = "${cache.eviction.time.validation-rule}"
  )
  public void clearInstanceDataCache() {
    log.info("Cleared cache entries for {}", VALIDATION_RULES_CACHE);
  }

}


# C:\Projects\local\mod-password-validator\src\main\java\org\folio\pv\service\exception\NoRulesMatchedException.java

package org.folio.pv.service.exception;

public class NoRulesMatchedException extends RuntimeException {
  public NoRulesMatchedException(String message) {
    super(message);
  }
}


# C:\Projects\local\mod-password-validator\src\main\java\org\folio\pv\service\exception\UserNotFoundException.java

package org.folio.pv.service.exception;

public class UserNotFoundException extends RuntimeException {

  private static final String MESSAGE = "User with given id not found";
  private final String userId;

  public UserNotFoundException(String userId) {
    super(MESSAGE);
    this.userId = userId;
  }

  public String getUserId() {
    return userId;
  }
}


# C:\Projects\local\mod-password-validator\src\main\java\org\folio\pv\service\PasswordValidatorService.java

package org.folio.pv.service;

import org.folio.pv.domain.dto.Password;
import org.folio.pv.domain.dto.PasswordCheck;
import org.folio.pv.domain.dto.ValidationResult;

public interface PasswordValidatorService {
  ValidationResult validatePasswordByRules(String tenant, Password passwordContainer);

  ValidationResult checkPassword(String tenant, PasswordCheck passwordCheck);
}


# C:\Projects\local\mod-password-validator\src\main\java\org\folio\pv\service\PasswordValidatorServiceImpl.java

package org.folio.pv.service;

import feign.FeignException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.apache.commons.lang3.builder.ToStringBuilder;
import org.folio.pv.client.UserClient;
import org.folio.pv.domain.RuleType;
import org.folio.pv.domain.ValidationType;
import org.folio.pv.domain.dto.Password;
import org.folio.pv.domain.dto.PasswordCheck;
import org.folio.pv.domain.dto.UserData;
import org.folio.pv.domain.dto.ValidationResult;
import org.folio.pv.domain.entity.PasswordValidationRule;
import org.folio.pv.service.exception.NoRulesMatchedException;
import org.folio.pv.service.exception.UserNotFoundException;
import org.folio.pv.service.validator.ValidatorRegistry;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
@Log4j2
public class PasswordValidatorServiceImpl implements PasswordValidatorService {
  public static final String VALIDATION_VALID_RESULT = "valid";
  public static final String VALIDATION_INVALID_RESULT = "invalid";

  private final ValidationRuleService validationRuleService;
  private final ValidatorRegistry validationRegistry;
  private final UserClient userClient;

  @Override
  public ValidationResult validatePasswordByRules(String tenant, final Password passwordContainer) {
    String userName = getUserNameByUserId(passwordContainer.getUserId());
    UserData userData = new UserData(passwordContainer.getUserId(), userName);
    String password = passwordContainer.getPassword();
    List<PasswordValidationRule> enabledRules = getSortedRules(validationRuleService.getEnabledRules(tenant));
    return validateRules(enabledRules, password, userData, true);
  }

  @Override
  public ValidationResult checkPassword(String tenant, PasswordCheck passwordCheck) {
    String username = passwordCheck.getUsername().trim();
    String password = passwordCheck.getPassword().trim();
    UserData userData = new UserData();
    userData.setName(username);
    List<PasswordValidationRule> rules = getSortedRules(getPasswordCheckRules(tenant));
    return validateRules(rules, password, userData, false);
  }

  private List<PasswordValidationRule> getSortedRules(List<PasswordValidationRule> rules) {
    if (rules == null) {
      return Collections.emptyList();
    }
    return rules.stream()
        .sorted(Comparator.comparing(PasswordValidationRule::getOrderNo))
        .toList();
  }

  private ValidationResult validateRules(List<PasswordValidationRule> rules, String password, UserData userData,
      boolean isStrongValidation) {
    List<String> validationMessages = new ArrayList<>();
    for (PasswordValidationRule rule : rules) {
      log.info("Validating password with rule: {}", ruleBriefDescription(rule));
      var validator = validationRegistry.validatorByRule(rule);
      var errors = validator.validate(password, userData);
      if (!errors.hasErrors()) {
        log.info("Rule passed: {}", ruleBriefDescription(rule));
      } else {
        validationMessages.addAll(errors.getErrorMessages());
        log.warn("Rule failed: {}, errors: {}", ruleBriefDescription(rule),
            String.join(", ", errors.getErrorMessages()));
        if (isStrongValidation && ValidationType.STRONG == rule.getValidationType()) {
          break;
        }
      }
    }
    ValidationResult validationResult = new ValidationResult();
    validationResult.setMessages(validationMessages);
    validationResult.setResult(validationMessages.isEmpty() ? VALIDATION_VALID_RESULT : VALIDATION_INVALID_RESULT);
    log.info("Validation result: {}", validationResult);
    return validationResult;
  }

  private List<PasswordValidationRule> getPasswordCheckRules(String tenant) {
    var rules = validationRuleService.getEnabledRules(tenant).stream()
        .filter(rule -> !RuleType.PROGRAMMATIC.equals(rule.getRuleType()))
        .collect(Collectors.toList());

    if (rules.isEmpty()) {
      throw new NoRulesMatchedException("No matched rules for password checking");
    }

    return rules;
  }

  private String getUserNameByUserId(String userId) {
    try {
      return userClient.getUserById(userId)
          .map(UserClient.UserDto::getUsername)
          .orElseThrow(() -> new UserNotFoundException(userId));
    } catch (FeignException.NotFound e) {
      log.warn("Failed on getting userName by given id: {}, msg: {}", userId, e.getMessage());
      throw new UserNotFoundException(userId);
    }
  }

  private String ruleBriefDescription(PasswordValidationRule rule) {
    return new ToStringBuilder(rule)
        .append("id", rule.getId())
        .append("name", rule.getName())
        .append("type", rule.getRuleType())
        .append("validationType", rule.getValidationType())
        .build();
  }
}


# C:\Projects\local\mod-password-validator\src\main\java\org\folio\pv\service\ValidationRuleService.java

package org.folio.pv.service;

import java.util.List;
import org.folio.pv.domain.dto.ValidationRule;
import org.folio.pv.domain.dto.ValidationRuleCollection;
import org.folio.pv.domain.entity.PasswordValidationRule;

public interface ValidationRuleService {

  ValidationRule getValidationRuleById(String ruleId);

  ValidationRuleCollection getValidationRules(Integer offset, Integer limit, String cql);

  ValidationRule createOrUpdateValidationRule(ValidationRule validationRule);

  ValidationRule storeValidationRule(ValidationRule validationRule);

  List<PasswordValidationRule> getEnabledRules(String tenant);
}


# C:\Projects\local\mod-password-validator\src\main\java\org\folio\pv\service\ValidationRuleServiceImpl.java

package org.folio.pv.service;

import static org.apache.commons.lang3.StringUtils.isBlank;

import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.folio.pv.domain.RuleState;
import org.folio.pv.domain.dto.ValidationRule;
import org.folio.pv.domain.dto.ValidationRuleCollection;
import org.folio.pv.domain.entity.PasswordValidationRule;
import org.folio.pv.mapper.ValidationRuleMapper;
import org.folio.pv.repository.ValidationRuleRepository;
import org.folio.spring.data.OffsetRequest;
import org.springframework.cache.annotation.CacheConfig;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
@CacheConfig(cacheNames = ValidationRuleServiceImpl.VALIDATION_RULES_CACHE)
@Log4j2
public class ValidationRuleServiceImpl implements ValidationRuleService {
  public static final String VALIDATION_RULES_CACHE = "validationRulesCache";

  private final ValidationRuleMapper validationRuleMapper;
  private final ValidationRuleRepository validationRuleRepository;

  @Override
  public ValidationRule getValidationRuleById(String ruleId) {
    var id = UUID.fromString(ruleId);

    return validationRuleRepository.findById(id).map(validationRuleMapper::mapEntityToDto).orElse(null);
  }

  @Override
  public ValidationRuleCollection getValidationRules(Integer offset, Integer limit, String cql) {
    log.debug("getValidationRules:: Attempts to find validationRules by [offset: {}, limit: {}, cql: {}]",
      offset, limit, cql);

    boolean isBlank = isBlank(cql);
    log.info("getValidationRules:: isBlank(cql) is {}", isBlank);

    var validationRuleList = isBlank
      ? validationRuleRepository.findAll(new OffsetRequest(offset, limit))
      : validationRuleRepository.findByCql(cql, new OffsetRequest(offset, limit));
    return validationRuleMapper.mapEntitiesToValidationRuleCollection(validationRuleList);
  }

  @Override
  @CacheEvict(allEntries = true)
  public ValidationRule createOrUpdateValidationRule(ValidationRule validationRule) {
    log.debug("createOrUpdateValidationRule:: by [validationRule: {}]", validationRule);

    var rule = validationRuleMapper.mapDtoToEntity(validationRule);
    if (rule.getId() == null) {
      if (rule.getCreatedDate() == null) {
        log.info("createOrUpdateValidationRule:: rule.getId() & rule.getCreatedDate() is null");
        rule.setCreatedDate(Timestamp.valueOf(LocalDateTime.now()));
      }
    } else {
      log.info("createOrUpdateValidationRule:: rule.getId() is not null");
      rule = validationRuleRepository.getById(rule.getId()).copyForUpdate(rule);
    }
    return validationRuleMapper.mapEntityToDto(validationRuleRepository.save(rule));
  }

  @Override
  @CacheEvict(allEntries = true)
  public ValidationRule storeValidationRule(ValidationRule validationRule) {
    var rule = validationRuleMapper.mapDtoToEntity(validationRule);
    return validationRuleMapper.mapEntityToDto(validationRuleRepository.save(rule));
  }

  @Override
  @Cacheable(key = "#tenant", unless = "#result == null")
  public List<PasswordValidationRule> getEnabledRules(String tenant) {
    return validationRuleRepository.findByRuleState(RuleState.ENABLED);
  }

}


# C:\Projects\local\mod-password-validator\src\main\java\org\folio\pv\service\validator\ProgrammaticValidator.java

package org.folio.pv.service.validator;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.folio.pv.domain.ValidationType;
import org.folio.pv.domain.dto.Password;
import org.folio.pv.domain.dto.UserData;
import org.folio.pv.domain.dto.ValidationErrors;
import org.folio.pv.domain.dto.ValidationResult;
import org.folio.pv.domain.entity.PasswordValidationRule;
import org.folio.spring.FolioExecutionContext;

@RequiredArgsConstructor(access = AccessLevel.PACKAGE)
@Log4j2
class ProgrammaticValidator implements Validator {

  private final PasswordValidationRule rule;
  private final FolioExecutionContext folioExecutionContext;
  private final ObjectMapper jacksonObjectMapper;


  @Override
  public ValidationErrors validate(String password, UserData user) {
    try (CloseableHttpClient client = HttpClients.createDefault()) {
      var httpPost = new HttpPost(folioExecutionContext.getOkapiUrl() + rule.getImplementationReference());

      addHeaders(httpPost);
      addBody(httpPost, password, user);

      log.info("Sending validation request to: {}", httpPost.getURI().toURL());
      var response = client.execute(httpPost);

      var buffer = new ByteArrayOutputStream();
      response.getEntity().writeTo(buffer);

      var statusCode = response.getStatusLine().getStatusCode();
      var body = buffer.toString();

      if (statusCode < 200 || statusCode > 202) {
        log.warn("Failed on getting validation response: [statusCode: {}, body: {}]", statusCode, body);
        if (ValidationType.STRONG == rule.getValidationType()) {
          throw new RuntimeException(body);
        } else {
          return ValidationErrors.none();
        }
      }

      log.info("Validation response: statusCode = {}, body = [{}]", statusCode, body);
      ValidationResult validationResult = jacksonObjectMapper.readValue(body, ValidationResult.class);
      return ValidationErrors.of(validationResult.getMessages());
    } catch (IOException e) {
      log.warn("Failed on reading validation response, msg: {}", e.getMessage());
      throw new RuntimeException(e);
    }
  }

  private void addBody(HttpPost httpPost, String password, UserData user) throws UnsupportedEncodingException,
    JsonProcessingException {
    httpPost.setEntity(new StringEntity(jacksonObjectMapper.writeValueAsString(
      new Password().password(password).userId(user.getId())))
    );
  }

  private void addHeaders(HttpPost httpPost) {
    folioExecutionContext.getOkapiHeaders()
      .forEach((key, values) -> values.forEach(value -> httpPost.addHeader(key, value)));
    // Some servers choke on the default accept string.
    httpPost.addHeader("accept", "*/*");
    httpPost.addHeader("content-type", "application/json");
  }

}


# C:\Projects\local\mod-password-validator\src\main\java\org\folio\pv\service\validator\PwnedPasswordValidator.java

package org.folio.pv.service.validator;

import java.util.List;
import java.util.Optional;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.apache.commons.lang3.StringUtils;
import org.folio.pv.client.PwnedClient;
import org.folio.pv.domain.dto.HashedPasswordUsage;
import org.folio.pv.domain.dto.PasswordHash;
import org.folio.pv.domain.dto.UserData;
import org.folio.pv.domain.dto.ValidationErrors;
import org.folio.pv.domain.entity.PasswordValidationRule;

@RequiredArgsConstructor(access = AccessLevel.PACKAGE)
@Log4j2
class PwnedPasswordValidator implements Validator {

  private final PasswordValidationRule rule;
  private final PwnedClient pwnedClient;


  @Override
  public ValidationErrors validate(String password, UserData user) {
    if (StringUtils.isBlank(password)) {
      log.warn("validate:: password is blank");
      return ValidationErrors.none();
    }

    var hash = new PasswordHash(password);

    log.debug("Checking password with prefix: {}", hash.getPrefix());

    List<HashedPasswordUsage> usages = pwnedClient.getPwdRange(hash.getPrefix());

    Optional<HashedPasswordUsage> knownHash = usages.stream()
      .filter(usage -> usage.getSuffix().equals(hash.getSuffix()) && usage.getUsageCount() > 0)
      .findFirst();

    log.info("Pwned Passwords validation: usageCount = {}",
      knownHash.map(HashedPasswordUsage::getUsageCount).orElse(0));

    return knownHash.isEmpty() ? ValidationErrors.none() : ValidationErrors.of(rule.getErrMessageId());
  }

}


# C:\Projects\local\mod-password-validator\src\main\java\org\folio\pv\service\validator\RegExpValidator.java

package org.folio.pv.service.validator;

import static org.apache.commons.lang3.StringUtils.isNotBlank;

import java.util.regex.Pattern;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.folio.pv.domain.dto.UserData;
import org.folio.pv.domain.dto.ValidationErrors;
import org.folio.pv.domain.entity.PasswordValidationRule;

@RequiredArgsConstructor(access = AccessLevel.PACKAGE)
@Log4j2
public class RegExpValidator implements Validator {

  private static final String REGEXP_USER_NAME_PLACEHOLDER = "<USER_NAME>";

  private final PasswordValidationRule rule;


  @Override
  public ValidationErrors validate(String password, UserData user) {
    var expression = rule.getRuleExpression();

    var failed = false;
    if (isNotBlank(expression)) {

      var exprWithUser = expression.replace(REGEXP_USER_NAME_PLACEHOLDER, user.getName());
      log.info("Validating password against regexp: {}", exprWithUser);

      var pattern = Pattern.compile(exprWithUser);

      failed = !pattern.matcher(password).matches();
    }

    if (failed) {
      log.warn("Password matching failed, errMsgId: {}", rule.getErrMessageId());
      return ValidationErrors.of(rule.getErrMessageId());
    }
    return ValidationErrors.none();
  }

}


# C:\Projects\local\mod-password-validator\src\main\java\org\folio\pv\service\validator\Validator.java

package org.folio.pv.service.validator;

import org.folio.pv.domain.dto.UserData;
import org.folio.pv.domain.dto.ValidationErrors;

public interface Validator {

  ValidationErrors validate(String password, UserData user);
}


# C:\Projects\local\mod-password-validator\src\main\java\org\folio\pv\service\validator\ValidatorRegistry.java

package org.folio.pv.service.validator;

import org.folio.pv.domain.entity.PasswordValidationRule;
import org.springframework.lang.NonNull;

public interface ValidatorRegistry {

  Validator validatorByRule(@NonNull PasswordValidationRule rule);

}


# C:\Projects\local\mod-password-validator\src\main\java\org\folio\pv\service\validator\ValidatorRegistryImpl.java

package org.folio.pv.service.validator;

import com.fasterxml.jackson.databind.ObjectMapper;
import java.util.Objects;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.folio.pv.client.PwnedClient;
import org.folio.pv.domain.RuleType;
import org.folio.pv.domain.entity.PasswordValidationRule;
import org.folio.spring.FolioExecutionContext;
import org.springframework.lang.NonNull;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
@Log4j2
class ValidatorRegistryImpl implements ValidatorRegistry {

  private static final String VALIDATOR_NOT_FOUND_ERROR = "Validator is not registered for rule type: %s";
  private final FolioExecutionContext folioExecutionContext;
  private final ObjectMapper jacksonObjectMapper;
  private final PwnedClient pwnedClient;


  @Override
  public Validator validatorByRule(@NonNull PasswordValidationRule rule) {
    Objects.requireNonNull(rule, "Validation rule is null");

    Validator validator;

    var ruleType = rule.getRuleType();
    log.info("validatorByRule:: ruleType is {}", rule.getRuleType());

    if (ruleType == RuleType.REGEXP) {
      validator = new RegExpValidator(rule);
    } else if (ruleType == RuleType.PROGRAMMATIC) {
      validator = new ProgrammaticValidator(rule, folioExecutionContext, jacksonObjectMapper);
    } else if (ruleType == RuleType.PWNEDPASSWORD) {
      validator = new PwnedPasswordValidator(rule, pwnedClient);
    } else {
      var errorMessage = String.format(VALIDATOR_NOT_FOUND_ERROR, ruleType);
      IllegalStateException e = new IllegalStateException(errorMessage);
      log.warn("Failed on creating validator, msg: {}", errorMessage);
      throw e;
    }

    return validator;
  }

}


