# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\borrowing-flow-chain-of-responsibility.feature

Feature: Testing Borrowing Flow chain of Responsibility

  Background:
    * url baseUrl
    * def proxyCall = karate.get('proxyCall', false)
    * def user = proxyCall == true ? admin : testAdmin
    * print 'user  is', user
    * callonce login user
    * def okapitokenUser = okapitoken
    * def headersUser = { 'Content-Type': 'application/json', 'x-okapi-token': '#(okapitokenUser)', 'x-okapi-tenant': '#(testTenant)', 'Accept': 'application/json'  }
    * configure headers = headersUser
    * callonce variables

  Scenario: Create Transaction and updating it from CREATED to AWAITING_PICKUP.
    * def transactionId = '10072'
    * def id1 = '3c497cc0-77b7-11ee-b962-0242ac120007'
    * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction-for-borrower.feature') { transactionId: '#(transactionId)', extItemId: '#(id1)', itemBarcode: '172' }
    * def updateToAwaitingPickupRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-awaiting-pickup.json')

    Given path '/transactions/' + transactionId + '/status'
    And request updateToAwaitingPickupRequest
    When method PUT
    Then status 200
    And match $.status == 'AWAITING_PICKUP'

  Scenario: Create Transaction and updating it from CREATED to ITEM_CHECKED_OUT.
    * def transactionId = '10073'
    * def id1 = '3c497cc0-77b7-11ee-b962-0242ac120008'
    * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction-for-borrower.feature') { transactionId: '#(transactionId)', extItemId: '#(id1)', itemBarcode: '173' }
    * def updateToItemCheckoutRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-item-check-out.json')

    Given path '/transactions/' + transactionId + '/status'
    And request updateToItemCheckoutRequest
    When method PUT
    Then status 200
    And match $.status == 'ITEM_CHECKED_OUT'

  Scenario: Create Transaction and updating it from CREATED to ITEM_CHECKED_IN.
    * def transactionId = '10074'
    * def id1 = '3c497cc0-77b7-11ee-b962-0242ac120009'
    * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction-for-borrower.feature') { transactionId: '#(transactionId)', extItemId: '#(id1)', itemBarcode: '174' }
    * def updateToItemCheckInRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-item-check-in.json')

    Given path '/transactions/' + transactionId + '/status'
    And request updateToItemCheckInRequest
    When method PUT
    Then status 200
    And match $.status == 'ITEM_CHECKED_IN'

  Scenario: Create Transaction and updating it from CREATED to CLOSED.
    * def transactionId = '10075'
    * def id1 = '3c497cc0-77b7-11ee-b962-0242ac130001'
    * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction-for-borrower.feature') { transactionId: '#(transactionId)', extItemId: '#(id1)', itemBarcode: '175' }
    * def updateToClosedRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-closed.json')

    Given path '/transactions/' + transactionId + '/status'
    And request updateToClosedRequest
    When method PUT
    Then status 200
    And match $.status == 'CLOSED'

  Scenario: Create Transaction and updating it from OPEN to ITEM_CHECKED_OUT.
    * def transactionId = '10076'
    * def id1 = '3c497cc0-77b7-11ee-b962-0242ac130002'
    * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction-for-borrower.feature') { transactionId: '#(transactionId)', extItemId: '#(id1)', itemBarcode: '176' }
    * def updateToOpenRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-open.json')

    Given path '/transactions/' + transactionId + '/status'
    And request updateToOpenRequest
    When method PUT
    Then status 200
    And match $.status == 'OPEN'

    * def updateToItemCheckoutRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-item-check-out.json')

    Given path '/transactions/' + transactionId + '/status'
    And request updateToItemCheckoutRequest
    When method PUT
    Then status 200
    And match $.status == 'ITEM_CHECKED_OUT'

  Scenario: Create Transaction and updating it from OPEN to ITEM_CHECKED_IN.
    * def transactionId = '10077'
    * def id1 = '3c497cc0-77b7-11ee-b962-0242ac130003'
    * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction-for-borrower.feature') { transactionId: '#(transactionId)', extItemId: '#(id1)', itemBarcode: '177' }
    * def updateToOpenRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-open.json')

    Given path '/transactions/' + transactionId + '/status'
    And request updateToOpenRequest
    When method PUT
    Then status 200
    And match $.status == 'OPEN'

    * def updateToItemCheckinRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-item-check-in.json')

    Given path '/transactions/' + transactionId + '/status'
    And request updateToItemCheckinRequest
    When method PUT
    Then status 200
    And match $.status == 'ITEM_CHECKED_IN'


  Scenario: Create Transaction and updating it from OPEN to CLOSED.
    * def transactionId = '10078'
    * def id1 = '3c497cc0-77b7-11ee-b962-0242ac130004'
    * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction-for-borrower.feature') { transactionId: '#(transactionId)', extItemId: '#(id1)', itemBarcode: '178' }
    * def updateToOpenRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-open.json')

    Given path '/transactions/' + transactionId + '/status'
    And request updateToOpenRequest
    When method PUT
    Then status 200
    And match $.status == 'OPEN'

    * def updateToClosedRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-closed.json')

    Given path '/transactions/' + transactionId + '/status'
    And request updateToClosedRequest
    When method PUT
    Then status 200
    And match $.status == 'CLOSED'

  Scenario: Create Transaction and updating it from AWAITING_PICKUP to ITEM_CHECKED_IN.
    * def transactionId = '10079'
    * def id1 = '3c497cc0-77b7-11ee-b962-0242ac130005'
    * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction-for-borrower.feature') { transactionId: '#(transactionId)', extItemId: '#(id1)', itemBarcode: '179' }
    * def updateToAwaitingPickupRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-awaiting-pickup.json')

    Given path '/transactions/' + transactionId + '/status'
    And request updateToAwaitingPickupRequest
    When method PUT
    Then status 200
    And match $.status == 'AWAITING_PICKUP'

    * def updateToItemCheckinRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-item-check-in.json')

    Given path '/transactions/' + transactionId + '/status'
    And request updateToItemCheckinRequest
    When method PUT
    Then status 200
    And match $.status == 'ITEM_CHECKED_IN'

  Scenario: Create Transaction and updating it from AWAITING_PICKUP to CLOSED.
    * def transactionId = '10080'
    * def id1 = '3c497cc0-77b7-11ee-b962-0242ac130006'
    * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction-for-borrower.feature') { transactionId: '#(transactionId)', extItemId: '#(id1)', itemBarcode: '180' }
    * def updateToAwaitingPickupRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-awaiting-pickup.json')

    Given path '/transactions/' + transactionId + '/status'
    And request updateToAwaitingPickupRequest
    When method PUT
    Then status 200
    And match $.status == 'AWAITING_PICKUP'

    * def updateToClosedRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-closed.json')

    Given path '/transactions/' + transactionId + '/status'
    And request updateToClosedRequest
    When method PUT
    Then status 200
    And match $.status == 'CLOSED'

  Scenario: Create Transaction and updating it from ITEM_CHECKED_OUT to CLOSED.
    * def transactionId = '10081'
    * def id1 = '3c497cc0-77b7-11ee-b962-0242ac130007'
    * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction-for-borrower.feature') { transactionId: '#(transactionId)', extItemId: '#(id1)', itemBarcode: '181' }
    * def updateToItemCheckoutRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-item-check-out.json')

    Given path '/transactions/' + transactionId + '/status'
    And request updateToItemCheckoutRequest
    When method PUT
    Then status 200
    And match $.status == 'ITEM_CHECKED_OUT'

    * def updateToClosedRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-closed.json')

    Given path '/transactions/' + transactionId + '/status'
    And request updateToClosedRequest
    When method PUT
    Then status 200
    And match $.status == 'CLOSED'

# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\borrowing-flow.feature

Feature: Borrowing Flow Scenarios

  Background:
    * url baseUrl
    * def proxyCall = karate.get('proxyCall', false)
    * def user = proxyCall == true ? testUser : testAdmin
    * print 'user  is', user
    * callonce login user
    * def okapitokenUser = okapitoken
    * def headersUser = { 'Content-Type': 'application/json', 'x-okapi-token': '#(okapitokenUser)', 'x-okapi-tenant': '#(testTenant)', 'Accept': 'application/json'  }
    * def key = ''
    * configure headers = headersUser
    * callonce variables
    * def startDate = callonce getCurrentUtcDate
    * configure retry = { count: 5, interval: 1000 }

  Scenario: Validation. If the userId and barcode is not exist already, error will be thrown.

    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def createDCBTransactionRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/create-dcb-transaction.json')
    * createDCBTransactionRequest.item.id = itemId20
    * createDCBTransactionRequest.item.barcode = itemBarcode20
    # not existing patron id patronIdNonExisting
    * createDCBTransactionRequest.patron.id = patronIdNonExisting
    # not existing patron barcode patronBarcodeNonExisting
    * createDCBTransactionRequest.patron.barcode = patronBarcodeNonExisting
    * createDCBTransactionRequest.pickup.servicePointId = servicePointId1
    * createDCBTransactionRequest.pickup.servicePointName = servicePointName1
    * createDCBTransactionRequest.role = 'BORROWER'

    * def orgPath = '/transactions/' + dcbTransactionIdValidation1
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    And request createDCBTransactionRequest
    When method POST
    Then status 404
    And match $.errors[0].message == 'Unable to find existing user with barcode '+ patronBarcodeNonExisting + ' and id ' + patronIdNonExisting + '.'

  Scenario: Validation. If the item barcode is already present in the inventory, error will be thrown.

    # create item with Barcode itemBarcodeAlreadyExists2
    * def materialTypeEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/item/material-type-entity-request.json')
    * materialTypeEntityRequest.id = intMaterialTypeId1
    * materialTypeEntityRequest.name = intMaterialTypeName1
    Given path 'material-types'
    And request materialTypeEntityRequest
    When method POST
    Then status 201

    # create item with barcode itemBarcodeAlreadyExists
    * def itemEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/item/item-entity-request.json')
    * itemEntityRequest.barcode = itemBarcodeAlreadyExists2
    * itemEntityRequest.id = itemId6
    * itemEntityRequest.materialType.id = intMaterialTypeId1
    * itemEntityRequest.status.name = 'Available'

    Given path 'inventory', 'items'
    And request itemEntityRequest
    When method POST
    Then status 201

     # create Transaction with itemBarcodeAlreadyExists2
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def createDCBTransactionRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/create-dcb-transaction.json')
    * createDCBTransactionRequest.item.id = itemId6
    # item with existing barcode itemBarcodeAlreadyExists2
    * createDCBTransactionRequest.item.barcode = itemBarcodeAlreadyExists2
    * createDCBTransactionRequest.patron.id = patronId2
    * createDCBTransactionRequest.patron.barcode = patronBarcode2
    * createDCBTransactionRequest.pickup.servicePointId = servicePointId1
    * createDCBTransactionRequest.pickup.servicePointName = servicePointName1
    * createDCBTransactionRequest.role = 'BORROWER'

    * def orgPath = '/transactions/' + dcbTransactionIdValidation2
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    And request createDCBTransactionRequest
    When method POST
    Then status 409
    And match $.errors[0].message == 'Unable to create item with barcode ' + itemBarcodeAlreadyExists2 + ' as it exists in inventory '

  Scenario: Validation. If item is not present in inventory, new virtual item will be created.

    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def createDCBTransactionRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/create-dcb-transaction.json')
    # item with id itemId40 and itemBarcode40 will be created automatically
    * createDCBTransactionRequest.item.id = itemId40
    * createDCBTransactionRequest.item.barcode = itemBarcode40
    * createDCBTransactionRequest.patron.id = patronId2
    * createDCBTransactionRequest.patron.barcode = patronBarcode2
    * createDCBTransactionRequest.pickup.servicePointName = servicePointName1
    * createDCBTransactionRequest.role = 'BORROWER'

    * def orgPath = '/transactions/' + dcbTransactionIdValidation8
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    And request createDCBTransactionRequest
    When method POST
    Then status 201
    And match $.status == 'CREATED'

    Given path 'request-storage', 'requests'
    Given param query = '(item.barcode= ' + itemBarcode40 + ')'
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.requests[0].status == 'Open - Not yet filled'
    * def requestId = $.requests[0].id
    * def existingRequestHoldingId = $.requests[0].holdingsRecordId
    * def existingRequestInstanceId = $.requests[0].instanceId

    # Since mod-dcb will not use servicePointId from transaction request, servicePoint id is fetched from inventory
    * def servicePointName = 'DCB_'+createDCBTransactionRequest.pickup.libraryCode+'_'+createDCBTransactionRequest.pickup.servicePointName
    Given path 'service-points'
    Given param query = '(name= ' + servicePointName + ')'
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.servicepoints[0].name == servicePointName
    * def servicePointId = $.servicepoints[0].id

    # Cancel transaction in order to reuse the same item id and item barcode.
    * def cancelRequestEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/request/cancel-request-entity-request.json')
    * cancelRequestEntityRequest.cancellationReasonId = cancellationReasonId
    * cancelRequestEntityRequest.cancelledByUserId = patronId2
    * cancelRequestEntityRequest.requesterId = patronId2
    * cancelRequestEntityRequest.requestLevel = 'Item'
    * cancelRequestEntityRequest.requestType = extRequestType
    * cancelRequestEntityRequest.holdingsRecordId = existingRequestHoldingId
    * cancelRequestEntityRequest.instanceId = existingRequestInstanceId
    * cancelRequestEntityRequest.itemId = itemId40
    * cancelRequestEntityRequest.pickupServicePointId = servicePointId

    Given path 'circulation', 'requests', requestId
    And request cancelRequestEntityRequest
    When method PUT
    Then status 204

    Given path 'circulation', 'requests', requestId
    When method GET
    Then status 200
    And match $.status == 'Closed - Cancelled'

    Given path 'transactions' , dcbTransactionIdValidation8 , 'status'
    And retry until response.status == 'CANCELLED'
    When method GET
    Then status 200
    And match $.status == 'CANCELLED'
    And match $.role == 'BORROWER'

  @GetTransactionStatusListAfterCancelled
  Scenario: Get Transaction status list after Cancelled
    * def endDate = call getCurrentUtcDate
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath
    Given path newPath
    And param apikey = key
    And param fromDate = startDate
    And param toDate = endDate
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.maximumPageNumber == 0
    And match response.transactions[0].id == dcbTransactionIdValidation8
    And match response.transactions[0].status == 'CANCELLED'

  Scenario: Validation. If virtual item already exists, it will be reused. Make sure same id and barcode should be used. itemId2 reused

    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def createDCBTransactionRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/create-dcb-transaction.json')
    # item with id itemId40 and itemBarcode40 will be created automatically
    * createDCBTransactionRequest.item.id = itemId40
    * createDCBTransactionRequest.item.barcode = itemBarcode40
    * createDCBTransactionRequest.patron.id = patronId2
    * createDCBTransactionRequest.patron.barcode = patronBarcode2
    * createDCBTransactionRequest.pickup.servicePointName = servicePointName1
    * createDCBTransactionRequest.role = 'BORROWER'

    * def orgPath = '/transactions/' + dcbTransactionIdValidation9
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    And request createDCBTransactionRequest
    And retry until responseStatus == 201
    When method POST
    Then status 201
    And match $.status == 'CREATED'

  Scenario: Validation. Material type in the request should be present in inventory or else error will be thrown.

    # create item with not existing material type
    * def itemEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/item/item-entity-request.json')
    * itemEntityRequest.barcode = itemBarcode50
    * itemEntityRequest.id = itemId50
    # not existing material type
    * itemEntityRequest.materialType.id = intMaterialTypeIdNonExisting
    * itemEntityRequest.status.name = 'Available'

    Given path 'inventory', 'items'
    And request itemEntityRequest
    When method POST
    Then status 422
    And match $.errors[0].message == 'Cannot set item.materialtypeid = ' + intMaterialTypeIdNonExisting + ' because it does not exist in material_type.id.'

    # If the material type is not given in the request, then we check for default material type as book in inventory, if it doesn't exist, we throw the error.
    * def materialTypeEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/item/material-type-entity-request.json')
    * materialTypeEntityRequest.name = 'book'
    Given path 'material-types'
    And request materialTypeEntityRequest
    When method GET
    Then status 200

  Scenario: Validation. If the user exist but the type is DCB, error will be thrown

    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def createDCBTransactionRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/create-dcb-transaction.json')
    * createDCBTransactionRequest.item.id = itemId311
    * createDCBTransactionRequest.item.barcode = itemBarcode311
    * createDCBTransactionRequest.patron.id = patronId51
    * createDCBTransactionRequest.patron.barcode = patronBarcode51
    * createDCBTransactionRequest.patron.group = patronGroupName
    * createDCBTransactionRequest.pickup.servicePointId = servicePointId21
    * createDCBTransactionRequest.pickup.servicePointName = servicePointName21
    * createDCBTransactionRequest.role = 'BORROWER'

    * def orgPath = '/transactions/' + dcbTransactionId311
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    And request createDCBTransactionRequest
    When method POST
    Then status 400
    And match $.errors[0].message == 'User with type dcb is retrieved. so unable to create transaction'

  @CreateDCBTransaction
  Scenario: Create DCB Transaction
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def createDCBTransactionRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/create-dcb-transaction.json')
    * createDCBTransactionRequest.item.id = itemId31
    * createDCBTransactionRequest.item.barcode = itemBarcode31
    * createDCBTransactionRequest.patron.id = patronId31
    * createDCBTransactionRequest.patron.barcode = patronBarcode31
    * createDCBTransactionRequest.patron.group = patronGroupName
    * createDCBTransactionRequest.pickup.servicePointName = 'borrower_sp1'
    * createDCBTransactionRequest.pickup.libraryCode = '6uclv'
    * createDCBTransactionRequest.role = 'BORROWER'

    * def orgPath = '/transactions/' + dcbTransactionId31
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    And request createDCBTransactionRequest
    When method POST
    Then status 201
    And match $.status == 'CREATED'

    * print 'Get Item status after creating dcb transaction'

    * url baseUrl
    Given path 'circulation-item'
    Given param query = '(barcode= ' +  itemBarcode31 + ')'
    When method GET
    Then status 200
    And match $.items[0].status.name == 'In transit'

    * print 'Get servicePoint details'

    * def servicePointName = 'DCB_'+createDCBTransactionRequest.pickup.libraryCode+'_'+createDCBTransactionRequest.pickup.servicePointName
    Given path 'service-points'
    Given param query = '(name= ' + servicePointName + ')'
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.servicepoints[0].name == servicePointName
    * def servicePointId = $.servicepoints[0].id

    * print 'Get request by barcode and item ID after creating dcb transaction'

    Given path 'request-storage', 'requests'
    Given param query = '(item.barcode= ' + itemBarcode31 + ')'
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.requests[0].status == 'Open - Not yet filled'
    And match $.requests[0].pickupServicePointId == servicePointId

    * print 'Create another request with same servicePoint details and verify the request details'

    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def createDCBTransactionRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/create-dcb-transaction.json')
    * createDCBTransactionRequest.item.id = itemId32
    * createDCBTransactionRequest.item.barcode = itemBarcode32
    * createDCBTransactionRequest.patron.id = patronId31
    * createDCBTransactionRequest.patron.barcode = patronBarcode31
    * createDCBTransactionRequest.patron.group = patronGroupName
    * createDCBTransactionRequest.pickup.servicePointName = 'borrower_sp1'
    * createDCBTransactionRequest.pickup.libraryCode = '6uclv'
    * createDCBTransactionRequest.role = 'BORROWER'

    * def orgPath = '/transactions/' + itemBarcode32
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    And request createDCBTransactionRequest
    When method POST
    Then status 201
    And match $.status == 'CREATED'

    * url baseUrl
    Given path 'request-storage', 'requests'
    Given param query = '(item.barcode= ' + itemBarcode32 + ')'
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.requests[0].status == 'Open - Not yet filled'
    And match $.requests[0].pickupServicePointId == servicePointId

  @GetTransactionStatusAfterCreatingDCBTransaction
  Scenario: Check Transaction status after creating dcb transaction
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/' + dcbTransactionId31 + '/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    When method GET
    Then status 200
    And match $.status == 'CREATED'
    And match $.role == 'BORROWER'


  @UpdateTransactionStatusToOpen
  Scenario: Update DCB transaction status to open.
    * def updateToOpenRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-open.json')
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/' + dcbTransactionId31 + '/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    And request updateToOpenRequest
    When method PUT
    Then status 200

  @GetTransactionStatusAfterUpdatingToOpen
  Scenario: Check Transaction status after updating it to open
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/' + dcbTransactionId31 + '/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    When method GET
    Then status 200
    And match $.status == 'OPEN'
    And match $.role == 'BORROWER'

  @GetTransactionStatusListAfterOpen
  Scenario: Get Transaction status list after Open
    * def endDate = call getCurrentUtcDate
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath
    Given path newPath
    And param apikey = key
    And param fromDate = startDate
    And param toDate = endDate
    When method GET
    Then status 200
    And match $.totalRecords == 2
    And match $.maximumPageNumber == 0
    And match response.transactions[0].id == dcbTransactionIdValidation8
    And match response.transactions[0].status == 'CANCELLED'
    And match response.transactions[1].id == dcbTransactionId31
    And match response.transactions[1].status == 'OPEN'

  @UpdateTransactionStatusToAwaitingPickup
  Scenario: Update DCB transaction status to AWAITING_PICKUP.
    * def updateToAwaitingPickupRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-awaiting-pickup.json')
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/' + dcbTransactionId31 + '/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    And request updateToAwaitingPickupRequest
    When method PUT
    Then status 200

  Scenario: Get Item status after updating it to awaiting pickup

    Given path 'circulation-item'
    Given param query = '(barcode= ' +  itemBarcode31 + ')'
    When method GET
    Then status 200
    And match $.items[0].status.name == 'Awaiting pickup'


  @GetTransactionStatusAfterUpdatingToAwaitingPickup
  Scenario: Check Transaction status after updating it to AWAITING_PICKUP
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/' + dcbTransactionId31 + '/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    When method GET
    Then status 200
    And match $.status == 'AWAITING_PICKUP'
    And match $.role == 'BORROWER'

  @GetTransactionStatusListAfterAwaitingPickup
  Scenario: Get Transaction status list after awaiting pickup
    * def endDate = call getCurrentUtcDate
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath
    Given path newPath
    And param apikey = key
    And param fromDate = startDate
    And param toDate = endDate
    When method GET
    Then status 200
    And match $.totalRecords == 3
    And match $.maximumPageNumber == 0
    And match response.transactions[0].id == dcbTransactionIdValidation8
    And match response.transactions[0].status == 'CANCELLED'
    And match response.transactions[1].id == dcbTransactionId31
    And match response.transactions[1].status == 'OPEN'
    And match response.transactions[2].id == dcbTransactionId31
    And match response.transactions[2].status == 'AWAITING_PICKUP'

  @UpdateTransactionStatusToItemCheckedOut
  Scenario: Update DCB transaction status to ITEM_CHECKED_OUT.
    * def updateToItemCheckoutRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-item-check-out.json')
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/' + dcbTransactionId31 + '/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    And request updateToItemCheckoutRequest
    When method PUT
    Then status 200

  Scenario: Get Item status after updating it to ITEM_CHECKED_OUT

    Given path 'circulation-item'
    Given param query = '(barcode= ' +  itemBarcode31 + ')'
    When method GET
    Then status 200
    And match $.items[0].status.name == 'Checked out'


  @GetTransactionStatusAfterUpdatingToItemCheckedOut
  Scenario: Check Transaction status after updating it to ITEM_CHECKED_OUT
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/' + dcbTransactionId31 + '/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    When method GET
    Then status 200
    And match $.status == 'ITEM_CHECKED_OUT'
    And match $.role == 'BORROWER'

  @GetTransactionStatusListAfterItemCheckOut
  Scenario: Get Transaction status list after Check out
    * def endDate = call getCurrentUtcDate
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath
    Given path newPath
    And param apikey = key
    And param fromDate = startDate
    And param toDate = endDate
    And param pageSize = 3
    And param pageNumber = 1
    When method GET
    Then status 200
    And match $.totalRecords == 4
    And match $.maximumPageNumber == 1
    And match response.transactions[0].id == dcbTransactionId31
    And match response.transactions[0].status == 'ITEM_CHECKED_OUT'

  Scenario: Get request by barcode and item ID after updating it to ITEM_CHECKED_OUT

    Given path 'request-storage', 'requests'
    Given param query = '(item.barcode= ' + itemBarcode31 + ')'
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.requests[0].status == 'Closed - Filled'

  Scenario: Get loan by item ID after updating it to ITEM_CHECKED_OUT

    Given path 'circulation-item'
    Given param query = '(barcode= ' +  itemBarcode31 + ')'
    When method GET
    Then status 200
    * def itemId = $.items[0].id

    Given path 'loan-storage', 'loans'
    Given param query = '( itemId = ' + itemId + ' )'
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.loans[0].userId == patronId31

  @UpdateTransactionStatusToItemCheckedIn
  Scenario: Update DCB transaction status to ITEM_CHECKED_IN.
    * def updateToItemCheckinRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-item-check-in.json')
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/' + dcbTransactionId31 + '/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    And request updateToItemCheckinRequest
    When method PUT
    Then status 200

  Scenario: Get loan by item ID after updating to ITEM_CHECKED_IN

    Given path 'circulation-item'
    Given param query = '(barcode= ' +  itemBarcode31 + ')'
    When method GET
    Then status 200
    * def itemId = $.items[0].id


    Given path 'loan-storage', 'loans'
    Given param query = '( itemId = ' + itemId + ' )'
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.loans[0].userId == patronId31

  Scenario: Get Item status after updating it to ITEM_CHECKED_IN

    Given path 'circulation-item'
    Given param query = '(barcode= ' +  itemBarcode31 + ')'
    When method GET
    Then status 200
    And match $.items[0].status.name == 'In transit'


  @GetTransactionStatusAfterUpdatingToItemCheckedIn
  Scenario: Check Transaction status after updating it to ITEM_CHECKED_IN
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/' + dcbTransactionId31 + '/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    When method GET
    Then status 200
    And match $.status == 'ITEM_CHECKED_IN'
    And match $.role == 'BORROWER'

  @GetTransactionStatusListAfterCheckIn
  Scenario: Get Transaction status list after Check In
    * def endDate = call getCurrentUtcDate
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath
    Given path newPath
    And param apikey = key
    And param fromDate = startDate
    And param toDate = endDate
    And param pageSize = 3
    And param pageNumber = 1
    When method GET
    Then status 200
    And match $.totalRecords == 5
    And match $.maximumPageNumber == 1
    And match response.transactions[0].id == dcbTransactionId31
    And match response.transactions[0].status == 'ITEM_CHECKED_OUT'
    And match response.transactions[1].id == dcbTransactionId31
    And match response.transactions[1].status == 'ITEM_CHECKED_IN'

  @UpdateTransactionStatusToClosed
  Scenario: Update DCB transaction status to closed.
    * def updateToClosedRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-closed.json')
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/' + dcbTransactionId31 + '/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    And request updateToClosedRequest
    When method PUT
    Then status 200

  @GetTransactionStatusAfterUpdatingToClosed
  Scenario: Check Transaction status after updating it to closed
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/' + dcbTransactionId31 + '/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    When method GET
    Then status 200
    And match $.status == 'CLOSED'
    And match $.role == 'BORROWER'

  @GetTransactionStatusListAfterClosed
  Scenario: Get Transaction status list after Closed
    * def endDate = call getCurrentUtcDate
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath
    Given path newPath
    And param apikey = key
    And param fromDate = startDate
    And param toDate = endDate
    And param pageSize = 1
    And param pageNumber = 5
    When method GET
    Then status 200
    And match $.totalRecords == 6
    And match $.maximumPageNumber == 5
    And match response.transactions[0].id == dcbTransactionId31
    And match response.transactions[0].status == 'CLOSED'

# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\borrowing-pickup.feature

Feature: Testing Borrowing-Pickup Flow

  Background:
    * url baseUrl
    * def proxyCall = karate.get('proxyCall', false)
    * def user = proxyCall == true ? testUser : testAdmin
    * print 'user  is', user
    * callonce login user
    * def okapitokenUser = okapitoken
    * def headersUser = { 'Content-Type': 'application/json', 'x-okapi-token': '#(okapitokenUser)', 'x-okapi-tenant': '#(testTenant)', 'Accept': 'application/json'  }
    * configure headers = headersUser
    * callonce variables
    * def startDate = callonce getCurrentUtcDate
    * configure retry = { count: 5, interval: 1000 }
    * def bpTransactionId1 = call uuid1
    * def bpTransactionId2 = call uuid1
    * def bpTransactionId3 = call uuid1
    * def bpItemId1 = call uuid1
    * def bpItemBarcode1 = call random_string
    * def bpItemId2 = call uuid1
    * def bpItemBarcode2 = call random_string

  Scenario: Validation. If the userId and barcode is not exist already, error will be thrown.

    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def createDCBTransactionRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/create-dcb-transaction.json')
    * createDCBTransactionRequest.item.id = itemId20
    * createDCBTransactionRequest.item.barcode = itemBarcode20
    # not existing patron id patronIdNonExisting
    * createDCBTransactionRequest.patron.id = patronIdNonExisting
    # not existing patron barcode patronBarcodeNonExisting
    * createDCBTransactionRequest.patron.barcode = patronBarcodeNonExisting
    * createDCBTransactionRequest.pickup.servicePointId = servicePointId21
    * createDCBTransactionRequest.pickup.servicePointName = servicePointName21
    * createDCBTransactionRequest.role = 'BORROWING-PICKUP'

    * def orgPath = '/transactions/' + dcbTransactionIdValidation1
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    And request createDCBTransactionRequest
    When method POST
    Then status 404
    And match $.errors[0].message == 'Unable to find existing user with barcode '+ patronBarcodeNonExisting + ' and id ' + patronIdNonExisting + '.'

  Scenario: Validation. If the item barcode is already present in the inventory, error will be thrown.
    * def holdingId = call uuid1
    * print 'holdingId is'
    * print holdingId
    Given call read(utilsPath+'@PostHoldings') {extHoldingsRecordId: #(holdingId)}

    * def materialTypeId = call uuid1
    * def materialTypeName = call random_string
    * def materialTypeEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/item/material-type-entity-request.json')
    * materialTypeEntityRequest.id = materialTypeId
    * materialTypeEntityRequest.name = materialTypeName
    Given path 'material-types'
    And request materialTypeEntityRequest
    When method POST
    Then status 201

    # create item with barcode itemBarcodeAlreadyExists
    * def itemId = call uuid1
    * def itemBarcode = call random_string
    * def itemEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/item/item-entity-request.json')
    * itemEntityRequest.barcode = itemBarcode
    * itemEntityRequest.id = itemId
    * itemEntityRequest.holdingsRecordId = holdingId
    * itemEntityRequest.materialType.id = materialTypeId
    * itemEntityRequest.materialType.name = materialTypeName
    * itemEntityRequest.status.name = 'Available'

    Given path 'inventory', 'items'
    And request itemEntityRequest
    When method POST
    Then status 201

     # create Transaction with itemBarcodeAlreadyExists
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def createDCBTransactionRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/create-dcb-transaction.json')
    * createDCBTransactionRequest.item.id = itemId
    # item with existing barcode itemBarcodeAlreadyExists
    * createDCBTransactionRequest.item.barcode = itemBarcode
    * createDCBTransactionRequest.patron.id = patronId1
    * createDCBTransactionRequest.patron.barcode = patronBarcode1
    * createDCBTransactionRequest.pickup.servicePointId = servicePointId21
    * createDCBTransactionRequest.role = 'BORROWING-PICKUP'

    * def transactionId = call uuid1
    * def orgPath = '/transactions/' + transactionId
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    And request createDCBTransactionRequest
    When method POST
    Then status 409
    And match $.errors[0].message == 'Unable to create item with barcode ' + itemBarcode + ' as it exists in inventory '

  Scenario: Validation. If item is not present in inventory, new virtual item will be created.

    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def createDCBTransactionRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/create-dcb-transaction.json')
    # item with id itemId30 and itemBarcode30 will be created automatically
    * createDCBTransactionRequest.item.id = bpItemId1
    * createDCBTransactionRequest.item.barcode = bpItemBarcode1
    * createDCBTransactionRequest.patron.id = patronId1
    * createDCBTransactionRequest.patron.barcode = patronBarcode1
    * createDCBTransactionRequest.pickup.servicePointId = servicePointId21
    * createDCBTransactionRequest.role = 'BORROWING-PICKUP'

    * def orgPath = '/transactions/' + bpTransactionId1
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    And request createDCBTransactionRequest
    When method POST
    Then status 201
    And match $.status == 'CREATED'

    Given path 'request-storage', 'requests'
    Given param query = '(item.barcode= ' + bpItemBarcode1 + ')'
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.requests[0].status == 'Open - Not yet filled'
    * def requestId = $.requests[0].id
    * def existingRequestHoldingId = $.requests[0].holdingsRecordId
    * def existingRequestInstanceId = $.requests[0].instanceId

    # Cancel transaction in order to reuse the same item id and item barcode.
    * def cancelRequestEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/request/cancel-request-entity-request.json')
    * cancelRequestEntityRequest.cancellationReasonId = cancellationReasonId
    * cancelRequestEntityRequest.cancelledByUserId = patronId1
    * cancelRequestEntityRequest.requesterId = patronId1
    * cancelRequestEntityRequest.requestLevel = 'Item'
    * cancelRequestEntityRequest.requestType = extRequestType
    * cancelRequestEntityRequest.holdingsRecordId = existingRequestHoldingId
    * cancelRequestEntityRequest.instanceId = existingRequestInstanceId
    * cancelRequestEntityRequest.itemId = bpItemId1
    * cancelRequestEntityRequest.pickupServicePointId = servicePointId21

    Given path 'circulation', 'requests', requestId
    And request cancelRequestEntityRequest
    When method PUT
    Then status 204

    Given path 'circulation', 'requests', requestId
    When method GET
    Then status 200
    And match $.status == 'Closed - Cancelled'

    Given path 'transactions' , bpTransactionId1 , 'status'
    And retry until response.status == 'CANCELLED'
    When method GET
    Then status 200
    And match $.status == 'CANCELLED'
    And match $.role == 'BORROWING-PICKUP'

  Scenario: Validation. If virtual item already exists, it will be reused. Make sure same id and barcode should be used. itemId30 reused

    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def createDCBTransactionRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/create-dcb-transaction.json')

    * createDCBTransactionRequest.item.id = bpItemId1
    * createDCBTransactionRequest.item.barcode = bpItemBarcode1
    * createDCBTransactionRequest.patron.id = patronId1
    * createDCBTransactionRequest.patron.barcode = patronBarcode1
    * createDCBTransactionRequest.pickup.servicePointId = servicePointId21
    * createDCBTransactionRequest.role = 'BORROWING-PICKUP'

    * def orgPath = '/transactions/' + bpTransactionId2
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    And request createDCBTransactionRequest
    And retry until responseStatus == 201
    When method POST
    Then status 201
    And match $.status == 'CREATED'

  Scenario: Validation. If the user exist but the type is DCB, error will be thrown

    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def createDCBTransactionRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/create-dcb-transaction.json')
    * createDCBTransactionRequest.item.id = bpItemId1
    * createDCBTransactionRequest.item.barcode = bpItemBarcode1
    * createDCBTransactionRequest.patron.id = patronId51
    * createDCBTransactionRequest.patron.barcode = patronBarcode51
    * createDCBTransactionRequest.patron.group = patronGroupName
    * createDCBTransactionRequest.pickup.servicePointId = servicePointId21
    * createDCBTransactionRequest.role = 'BORROWING-PICKUP'

    * def transactionId = call uuid1

    * def orgPath = '/transactions/' + transactionId
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    And request createDCBTransactionRequest
    When method POST
    Then status 400
    And match $.errors[0].message == 'User with type dcb is retrieved. so unable to create transaction'

  @PerformDCBStatusTransitionForBorrowingPickupRole
  Scenario: Create DCB Transaction
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def createDCBTransactionRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/create-dcb-transaction.json')
    * def orgPath = '/transactions/' + bpTransactionId3
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath
    * createDCBTransactionRequest.item.id = bpItemId2
    * createDCBTransactionRequest.item.barcode = bpItemBarcode2
    * createDCBTransactionRequest.patron.id = patronId21
    * createDCBTransactionRequest.patron.barcode = patronBarcode21
    * createDCBTransactionRequest.patron.group = patronGroupName
    * createDCBTransactionRequest.pickup.servicePointId = servicePointId21
    * createDCBTransactionRequest.role = 'BORROWING-PICKUP'

    Given path newPath
    And param apikey = key
    And request createDCBTransactionRequest
    When method POST
    Then status 201
    And match $.status == 'CREATED'

    * print 'Get Item status after creating dcb transaction'
    * url baseUrl
    Given path 'circulation-item'
    Given param query = '(barcode= ' +  bpItemBarcode2 + ')'
    When method GET
    Then status 200
    And match $.items[0].status.name == 'In transit'

    * print 'Get request by barcode and item ID after creating dcb transaction'
    Given path 'request-storage', 'requests'
    Given param query = '(item.barcode= ' + bpItemBarcode2 + ')'
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.requests[0].status == 'Open - Not yet filled'

    * print 'Check Transaction status after creating dcb transaction'
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/' + bpTransactionId3 + '/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    When method GET
    Then status 200
    And match $.status == 'CREATED'
    And match $.role == 'BORROWING-PICKUP'

    * print 'Update DCB transaction status to Open'
    * def updateToOpenRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-open.json')
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/' + bpTransactionId3 + '/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    And request updateToOpenRequest
    When method PUT
    Then status 200

    * print 'Check Transaction status after updating it to open'
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/' + bpTransactionId3 + '/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    When method GET
    Then status 200
    And match $.status == 'OPEN'
    And match $.role == 'BORROWING-PICKUP'

    * print 'call item check-in manually'
    * url baseUrl
    * def intCheckInDate = call read('classpath:volaris/mod-dcb/eureka-features/util/get-time-now-function.js')
    * def checkInRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/check-in/check-in-by-barcode-entity-request.json')
    * checkInRequest.servicePointId = servicePointId21
    * checkInRequest.itemBarcode = bpItemBarcode2

    Given path 'circulation', 'check-in-by-barcode'
    And request checkInRequest
    When method POST
    Then status 200
    * call pause 5000

    * print 'Get Item status after manual check in'

    Given path 'circulation-item'
    Given param query = '(barcode= ' +  bpItemBarcode2 + ')'
    When method GET
    Then status 200
    And match $.items[0].status.name == 'Awaiting pickup'

    * print 'Check Transaction status after manual check in'
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/' + bpTransactionId3 + '/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    When method GET
    Then status 200
    And match $.status == 'AWAITING_PICKUP'
    And match $.role == 'BORROWING-PICKUP'

    * print 'do check out'
    * url baseUrl
    * def checkOutByBarcodeId = call uuid1
    * def checkOutByBarcodeEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/check-out/check-out-by-barcode-entity-request.json')
    * checkOutByBarcodeEntityRequest.itemBarcode = bpItemBarcode2
    * checkOutByBarcodeEntityRequest.userBarcode = patronBarcode21
    * checkOutByBarcodeEntityRequest.servicePointId = servicePointId21

    Given path 'circulation', 'check-out-by-barcode'
    And request checkOutByBarcodeEntityRequest
    When method POST
    Then status 201
    * call pause 5000

    * print 'Get Item status after manual check out'

    Given path 'circulation-item'
    Given param query = '(barcode= ' +  bpItemBarcode2 + ')'
    When method GET
    Then status 200
    And match $.items[0].status.name == 'Checked out'

    * print 'Get request by barcode and item ID after manual check out'
    Given path 'request-storage', 'requests'
    Given param query = '(item.barcode= ' + bpItemBarcode2 + ')'
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.requests[0].status == 'Closed - Filled'

    Given path 'circulation-item'
    Given param query = '(barcode= ' +  bpItemBarcode2 + ')'
    When method GET
    Then status 200
    * def itemId = $.items[0].id

    * print 'Get loan by item ID after manual check out'
    Given path 'loan-storage', 'loans'
    Given param query = '( itemId = ' + itemId + ' )'
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.loans[0].userId == patronId21

    * print 'Check Transaction status after manual check out'
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/' + bpTransactionId3 + '/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    When method GET
    Then status 200
    And match $.status == 'ITEM_CHECKED_OUT'
    And match $.role == 'BORROWING-PICKUP'

    * print 'current item check-in record and its status'
    * url baseUrl
    * def intCheckInDate = call read('classpath:volaris/mod-dcb/eureka-features/util/get-time-now-function.js')
    * def checkInRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/check-in/check-in-by-barcode-entity-request.json')
    * checkInRequest.servicePointId = servicePointId21
    * checkInRequest.itemBarcode = bpItemBarcode2

    Given path 'circulation', 'check-in-by-barcode'
    And request checkInRequest
    When method POST
    Then status 200
    * call pause 5000

    * print 'Get loan by item ID after manual check in'

    Given path 'circulation-item'
    Given param query = '(barcode= ' +  bpItemBarcode2 + ')'
    When method GET
    Then status 200
    * def itemId = $.items[0].id

    Given path 'loan-storage', 'loans'
    Given param query = '( itemId = ' + itemId + ' )'
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.loans[0].userId == patronId21
    And match $.loans[0].status.name == 'Closed'

    * print 'Get Item status after manual check in 2'

    Given path 'circulation-item'
    Given param query = '(barcode= ' +  bpItemBarcode2 + ')'
    When method GET
    Then status 200
    And match $.items[0].status.name == 'In transit'

    * print 'Check Transaction status after manual check in'
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/' + bpTransactionId3 + '/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    When method GET
    Then status 200
    And match $.status == 'ITEM_CHECKED_IN'
    And match $.role == 'BORROWING-PICKUP'

    * print 'Update DCB transaction status to closed.'
    * def updateToClosedRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-closed.json')
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/' + bpTransactionId3 + '/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    And request updateToClosedRequest
    When method PUT
    Then status 200

    * print 'Check Transaction status after updating it to closed'
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/' + bpTransactionId3 + '/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    When method GET
    Then status 200
    And match $.status == 'CLOSED'
    And match $.role == 'BORROWING-PICKUP'

# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\cancelling-flow-for-borrower-flow.feature

Feature: Testing Borrower Flow Cancellation

  Background:
    * url baseUrl

    * callonce login testAdmin
    * def okapitokenUser = okapitoken
    * def headersUser = { 'Content-Type': 'application/json', 'x-okapi-token': '#(okapitokenUser)', 'x-okapi-tenant': '#(testTenant)', 'Accept': 'application/json, text/plain'  }
    * configure headers = headersUser
    * callonce variables
    * configure retry = { count: 5, interval: 1000 }


  Scenario: Cancel DCB Transaction manually
    * def transactionId = '100'
    * def id1 = 'a9b73276-77b6-11ee-b962-0242ac120003'
    * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction-for-borrower.feature') { transactionId: '#(transactionId)', extItemId: '#(id1)', itemBarcode: '1X' }
    * def updateToCancelRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-cancel.json')

    Given path 'transactions' , transactionId , 'status'
    And request updateToCancelRequest
    When method PUT
    Then status 200

    Given path 'transactions' , transactionId , 'status'
    And retry until response.status == 'CANCELLED'
    When method GET
    Then status 200
    And match $.status == 'CANCELLED'
    And match $.role == 'BORROWER'

    Given path 'request-storage', 'requests'
    Given param query = '(item.barcode= ' + '1X)'
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.requests[0].status == 'Closed - Cancelled'

  Scenario: Cancel DCB Transaction manually after OPEN
    * def transactionId = '200'
    * def id1 = 'a9b73276-77b6-11ee-b962-0242ac120004'
    * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction-for-borrower.feature') { transactionId: '#(transactionId)', extItemId: '#(id1)', itemBarcode: '2X' }
    * def updateToCancelRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-cancel.json')

    * def updateToOpenRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-open.json')

    Given path 'transactions' , transactionId , 'status'
    And request updateToOpenRequest
    When method PUT
    Then status 200

    Given path 'transactions' , transactionId , 'status'
    When method GET
    Then status 200
    And match $.status == 'OPEN'
    And match $.role == 'BORROWER'

    Given path 'transactions' , transactionId , 'status'
    And request updateToCancelRequest
    When method PUT
    Then status 200

    Given path 'transactions' , transactionId , 'status'
    And retry until response.status == 'CANCELLED'
    When method GET
    Then status 200
    And match $.status == 'CANCELLED'
    And match $.role == 'BORROWER'

    Given path 'request-storage', 'requests'
    Given param query = '(item.barcode= ' + '2X)'
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.requests[0].status == 'Closed - Cancelled'

  Scenario: Cancel DCB Transaction manually after AWAITING_PICKUP
    * def transactionId = '300'
    * def id1 = 'a9b73276-77b6-11ee-b962-0242ac120005'
    * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction-for-borrower.feature') { transactionId: '#(transactionId)', extItemId: '#(id1)', itemBarcode: '3X' }
    * def updateToCancelRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-cancel.json')


    * def updateToAwaitingPickupRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-awaiting-pickup.json')

    Given path 'transactions' , transactionId , 'status'
    And request updateToAwaitingPickupRequest
    When method PUT
    Then status 200

    Given path 'transactions' , transactionId , 'status'
    When method GET
    Then status 200
    And match $.status == 'AWAITING_PICKUP'
    And match $.role == 'BORROWER'

    Given path 'transactions' , transactionId , 'status'
    And request updateToCancelRequest
    When method PUT
    Then status 200

    Given path 'transactions' , transactionId , 'status'
    And retry until response.status == 'CANCELLED'
    When method GET
    Then status 200
    And match $.status == 'CANCELLED'
    And match $.role == 'BORROWER'

    Given path 'request-storage', 'requests'
    Given param query = '(item.barcode= ' + '3X)'
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.requests[0].status == 'Closed - Cancelled'

  #Negative
  Scenario: Cancel DCB Transaction manually after ITEM_CHECKED_OUT
    * def transactionId = '400'
    * def id1 = 'a9b73276-77b6-11ee-b962-0242ac120006'
    * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction-for-borrower.feature') { transactionId: '#(transactionId)', extItemId: '#(id1)', itemBarcode: '4X' }
    * def updateToCancelRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-cancel.json')

    * def updateToAwaitingPickupRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-awaiting-pickup.json')

    Given path 'transactions' , transactionId , 'status'
    And request updateToAwaitingPickupRequest
    When method PUT
    Then status 200

    Given path 'transactions' , transactionId , 'status'
    When method GET
    Then status 200
    And match $.status == 'AWAITING_PICKUP'
    And match $.role == 'BORROWER'

    * def updateToItemCheckedOutRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-item-check-out.json')

    Given path 'transactions' , transactionId , 'status'
    And request updateToItemCheckedOutRequest
    When method PUT
    Then status 200

    Given path 'transactions' , transactionId , 'status'
    When method GET
    Then status 200
    And match $.status == 'ITEM_CHECKED_OUT'
    And match $.role == 'BORROWER'

    Given path 'transactions' , transactionId , 'status'
    And request updateToCancelRequest
    When method PUT
    Then status 400
    And match $.errors[0].message == 'Cannot cancel transaction dcbTransactionId: 400. Transaction already in status: ITEM_CHECKED_OUT: '

   #Negative
   Scenario: Cancel DCB Transaction manually after ITEM_CHECKED_IN
     * def transactionId = '500'
     * def id1 = 'a9b73276-77b6-11ee-b962-0242ac120007'
     * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction-for-borrower.feature') { transactionId: '#(transactionId)', extItemId: '#(id1)', itemBarcode: '5X' }
     * def updateToCancelRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-cancel.json')

     * def updateToAwaitingPickupRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-awaiting-pickup.json')

     Given path 'transactions' , transactionId , 'status'
     And request updateToAwaitingPickupRequest
     When method PUT
     Then status 200

     Given path 'transactions' , transactionId , 'status'
     When method GET
     Then status 200
     And match $.status == 'AWAITING_PICKUP'
     And match $.role == 'BORROWER'

     * def updateToItemCheckedOutRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-item-check-out.json')

     Given path 'transactions' , transactionId , 'status'
     And request updateToItemCheckedOutRequest
     When method PUT
     Then status 200

     Given path 'transactions' , transactionId , 'status'
     When method GET
     Then status 200
     And match $.status == 'ITEM_CHECKED_OUT'
     And match $.role == 'BORROWER'

     * def updateToItemCheckedInRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-item-check-in.json')

     Given path 'transactions' , transactionId , 'status'
     And request updateToItemCheckedInRequest
     When method PUT
     Then status 200

     Given path 'transactions' , transactionId , 'status'
     When method GET
     Then status 200
     And match $.status == 'ITEM_CHECKED_IN'
     And match $.role == 'BORROWER'

     Given path 'transactions' , transactionId , 'status'
     And request updateToCancelRequest
     When method PUT
     Then status 400
     And match $.errors[0].message == 'Cannot cancel transaction dcbTransactionId: 500. Transaction already in status: ITEM_CHECKED_IN: '

  #Negative
  Scenario: Cancel DCB Transaction manually after CLOSED
    * def transactionId = '700'
    * def id1 = 'a9b73276-77b6-12ee-b962-0242ac120007'
    * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction-for-borrower.feature') { transactionId: '#(transactionId)', extItemId: '#(id1)', itemBarcode: '7X' }
    * def updateToCancelRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-cancel.json')
    * def updateToCloseRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-close.json')

    * def updateToAwaitingPickupRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-awaiting-pickup.json')

    Given path 'transactions' , transactionId , 'status'
    And request updateToAwaitingPickupRequest
    When method PUT
    Then status 200

    Given path 'transactions' , transactionId , 'status'
    When method GET
    Then status 200
    And match $.status == 'AWAITING_PICKUP'
    And match $.role == 'BORROWER'

    * def updateToItemCheckedOutRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-item-check-out.json')

    Given path 'transactions' , transactionId , 'status'
    And request updateToItemCheckedOutRequest
    When method PUT
    Then status 200

    Given path 'transactions' , transactionId , 'status'
    When method GET
    Then status 200
    And match $.status == 'ITEM_CHECKED_OUT'
    And match $.role == 'BORROWER'

    * def updateToItemCheckedInRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-item-check-in.json')

    Given path 'transactions' , transactionId , 'status'
    And request updateToItemCheckedInRequest
    When method PUT
    Then status 200

    Given path 'transactions' , transactionId , 'status'
    When method GET
    Then status 200
    And match $.status == 'ITEM_CHECKED_IN'
    And match $.role == 'BORROWER'

    Given path 'transactions' , transactionId , 'status'
    And request updateToCloseRequest
    When method PUT
    Then status 200

    Given path 'transactions' , transactionId , 'status'
    And request updateToCancelRequest
    When method PUT
    Then status 400
    And match $.errors[0].message == 'Cannot cancel transaction dcbTransactionId: 700. Transaction already in status: CLOSED: '

  #Negative
  Scenario: Cancel DCB Transaction automatically
    * def transactionId = '600'
    * def id1 = 'a9b73276-77b6-11ee-b962-0242ac120008'
    * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction-for-borrower.feature') { transactionId: '#(transactionId)', extItemId: '#(id1)', itemBarcode: '6X' }
    Given path 'request-storage', 'requests'
    Given param query = '(item.barcode= ' + '6X)'
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.requests[0].status == 'Open - Not yet filled'
    * def requestId = $.requests[0].id
    * def existingRequestHoldingId = $.requests[0].holdingsRecordId
    * def existingRequestInstanceId = $.requests[0].instanceId

    * def cancelRequestEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/request/cancel-request-entity-request.json')
    * cancelRequestEntityRequest.cancellationReasonId = cancellationReasonId
    * cancelRequestEntityRequest.cancelledByUserId = extUserId
    * cancelRequestEntityRequest.requesterId = extUserId
    * cancelRequestEntityRequest.requestLevel = 'Item'
    * cancelRequestEntityRequest.requestType = extRequestType
    * cancelRequestEntityRequest.holdingsRecordId = existingRequestHoldingId
    * cancelRequestEntityRequest.instanceId = existingRequestInstanceId
    * cancelRequestEntityRequest.itemId = id1
    * cancelRequestEntityRequest.pickupServicePointId = servicePointId

    Given path 'circulation', 'requests', requestId
    And request cancelRequestEntityRequest
    When method PUT
    Then status 204

    Given path 'circulation', 'requests', requestId
    When method GET
    Then status 200
    And match $.status == 'Closed - Cancelled'


    Given path 'transactions' , transactionId , 'status'
    And retry until response.status == 'CANCELLED'
    When method GET
    Then status 200
    And match $.status == 'CANCELLED'
    And match $.role == 'BORROWER'





# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\cancelling-flow-for-borrowing-pickup-flow.feature

Feature: Testing Lending Flow Cancellation

  Background:
    * url baseUrl
    * callonce login testAdmin
    * def okapitokenUser = okapitoken
    * def headersUser = { 'Content-Type': 'application/json', 'x-okapi-token': '#(okapitokenUser)', 'x-okapi-tenant': '#(testTenant)', 'Accept': 'application/json, text/plain'  }
    * configure headers = headersUser
    * callonce variables
    * configure retry = { count: 5, interval: 1000 }

  Scenario: Cancel DCB Transaction manually
    * def transactionId = '0A0'
    * def id1 = 'a9b73276-77b6-11ee-b962-0242ac120002'
    * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction-for-borrowing-pickup.feature') { transactionId: '#(transactionId)', extItemId: '#(id1)', itemBarcode: 'abcd' }
    * def updateToCancelRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-cancel.json')

    Given path 'transactions' , transactionId , 'status'
    And request updateToCancelRequest
    When method PUT
    Then status 200

    Given path 'transactions' , transactionId , 'status'
    And retry until response.status == 'CANCELLED'
    When method GET
    Then status 200
    And match $.status == 'CANCELLED'
    And match $.role == 'BORROWING-PICKUP'

    Given path 'request-storage', 'requests'
    Given param query = '(item.barcode= ' + 'abcd)'
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.requests[0].status == 'Closed - Cancelled'

  Scenario: Cancel DCB Transaction manually after OPEN
    * def transactionId = '0B0'
    * def id1 = 'b9b73276-77b6-11ee-b962-0242ac120002'
    * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction-for-borrowing-pickup.feature') { transactionId: '#(transactionId)', extItemId: '#(id1)', itemBarcode: '01' }
    * def updateToCancelRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-cancel.json')
    * def updateToOpenRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-open.json')

    Given path 'transactions' , transactionId , 'status'
    And request updateToOpenRequest
    When method PUT
    Then status 200

    Given path 'transactions' , transactionId , 'status'
    When method GET
    Then status 200
    And match $.status == 'OPEN'
    And match $.role == 'BORROWING-PICKUP'

    Given path 'transactions' , transactionId , 'status'
    And request updateToCancelRequest
    When method PUT
    Then status 200

    Given path 'transactions' , transactionId , 'status'
    And retry until response.status == 'CANCELLED'
    When method GET
    Then status 200
    And match $.status == 'CANCELLED'
    And match $.role == 'BORROWING-PICKUP'

    Given path 'request-storage', 'requests'
    Given param query = '(item.barcode= ' + '01)'
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.requests[0].status == 'Closed - Cancelled'

  Scenario: Cancel DCB Transaction manually after AWAITING_PICKUP
    * def transactionId = '0C0'
    * def id1 = 'c9b73276-77b6-11ee-b962-0242ac120002'
    * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction-for-borrowing-pickup.feature') { transactionId: '#(transactionId)', extItemId: '#(id1)', itemBarcode: '02' }
    * def updateToCancelRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-cancel.json')
    * def updateToOpenRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-open.json')

    * def intCheckInDate = call read('classpath:volaris/mod-dcb/eureka-features/util/get-time-now-function.js')
    * def checkInRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/check-in/check-in-by-barcode-entity-request.json')
    * set checkInRequest.itemBarcode = '02'

    Given path 'circulation', 'check-in-by-barcode'
    And request checkInRequest
    When method POST
    Then status 200
    And match $.item.barcode == '02'
    And match $.item.status.name == 'Awaiting pickup'
    * call pause 5000

    Given path 'transactions' , transactionId , 'status'
    When method GET
    Then status 200
    And match $.status == 'AWAITING_PICKUP'
    And match $.role == 'BORROWING-PICKUP'

    Given path 'transactions' , transactionId , 'status'
    And request updateToCancelRequest
    When method PUT
    Then status 200

    Given path 'transactions' , transactionId , 'status'
    And retry until response.status == 'CANCELLED'
    When method GET
    Then status 200
    And match $.status == 'CANCELLED'
    And match $.role == 'BORROWING-PICKUP'

    Given path 'request-storage', 'requests'
    Given param query = '(item.barcode= ' + '02)'
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.requests[0].status == 'Closed - Cancelled'

  #Negative
  Scenario: Cancel DCB Transaction manually after ITEM_CHECKED_OUT
    * def transactionId = '0D0'
    * def id1 = 'd9b73276-77b6-11ee-b962-0242ac120002'
    * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction-for-borrowing-pickup.feature') { transactionId: '#(transactionId)', extItemId: '#(id1)', itemBarcode: '03' }
    * def updateToCancelRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-cancel.json')
    * def updateToOpenRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-open.json')

    * def intCheckInDate = call read('classpath:volaris/mod-dcb/eureka-features/util/get-time-now-function.js')
    * def checkInRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/check-in/check-in-by-barcode-entity-request.json')
    * set checkInRequest.itemBarcode = '03'

    Given path 'circulation', 'check-in-by-barcode'
    And request checkInRequest
    When method POST
    Then status 200
    And match $.item.barcode == '03'
    And match $.item.status.name == 'Awaiting pickup'
    * call pause 5000

    Given path 'transactions' , transactionId , 'status'
    When method GET
    Then status 200
    And match $.status == 'AWAITING_PICKUP'
    And match $.role == 'BORROWING-PICKUP'

    * def checkOutByBarcodeEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/check-out/check-out-by-barcode-entity-request.json')
    * checkOutByBarcodeEntityRequest.userBarcode = extUserBarcode
    * checkOutByBarcodeEntityRequest.itemBarcode = '03'
    * checkOutByBarcodeEntityRequest.servicePointId = servicePointId
    Given path 'circulation', 'check-out-by-barcode'
    And request checkOutByBarcodeEntityRequest
    When method POST
    Then status 201
    * call pause 5000

    Given path 'transactions' , transactionId , 'status'
    When method GET
    Then status 200
    And match $.status == 'ITEM_CHECKED_OUT'
    And match $.role == 'BORROWING-PICKUP'

    Given path 'transactions' , transactionId , 'status'
    And request updateToCancelRequest
    When method PUT
    Then status 400
    And match $.errors[0].message == 'Cannot cancel transaction dcbTransactionId: 0D0. Transaction already in status: ITEM_CHECKED_OUT: '

  #Negative
  Scenario: Cancel DCB Transaction manually after ITEM_CHECKED_IN
    * def transactionId = '0E0'
    * def id1 = 'e9b73276-77b6-11ee-b962-0242ac120002'
    * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction-for-borrowing-pickup.feature') { transactionId: '#(transactionId)', extItemId: '#(id1)', itemBarcode: '04' }
    * def updateToCancelRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-cancel.json')
    * def updateToOpenRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-open.json')

    * def intCheckInDate = call read('classpath:volaris/mod-dcb/eureka-features/util/get-time-now-function.js')
    * def checkInRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/check-in/check-in-by-barcode-entity-request.json')
    * set checkInRequest.itemBarcode = '04'

    Given path 'circulation', 'check-in-by-barcode'
    And request checkInRequest
    When method POST
    Then status 200
    And match $.item.barcode == '04'
    And match $.item.status.name == 'Awaiting pickup'
    * call pause 5000

    Given path 'transactions' , transactionId , 'status'
    When method GET
    Then status 200
    And match $.status == 'AWAITING_PICKUP'
    And match $.role == 'BORROWING-PICKUP'

    * def checkOutByBarcodeEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/check-out/check-out-by-barcode-entity-request.json')
    * checkOutByBarcodeEntityRequest.userBarcode = extUserBarcode
    * checkOutByBarcodeEntityRequest.itemBarcode = '04'
    * checkOutByBarcodeEntityRequest.servicePointId = servicePointId
    Given path 'circulation', 'check-out-by-barcode'
    And request checkOutByBarcodeEntityRequest
    When method POST
    Then status 201
    * call pause 5000

    Given path 'transactions' , transactionId , 'status'
    When method GET
    Then status 200
    And match $.status == 'ITEM_CHECKED_OUT'
    And match $.role == 'BORROWING-PICKUP'

    * def intCheckInDate = call read('classpath:volaris/mod-dcb/eureka-features/util/get-time-now-function.js')
    * def checkInRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/check-in/check-in-by-barcode-entity-request.json')
    * set checkInRequest.itemBarcode = '04'

    Given path 'circulation', 'check-in-by-barcode'
    And request checkInRequest
    When method POST
    Then status 200
    And match $.item.barcode == '04'
    And match $.item.status.name == 'In transit'
    * call pause 5000

    Given path 'transactions' , transactionId , 'status'
    When method GET
    Then status 200
    And match $.status == 'ITEM_CHECKED_IN'
    And match $.role == 'BORROWING-PICKUP'

    Given path 'transactions' , transactionId , 'status'
    And request updateToCancelRequest
    When method PUT
    Then status 400
    And match $.errors[0].message == 'Cannot cancel transaction dcbTransactionId: 0E0. Transaction already in status: ITEM_CHECKED_IN: '

  Scenario: Cancel DCB Transaction automatically
    * def transactionId = '0F0'
    * def id1 = 'f9b73276-77b6-11ee-b962-0242ac120002'
    * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction-for-borrowing-pickup.feature') { transactionId: '#(transactionId)', extItemId: '#(id1)', itemBarcode: '05' }

    Given path 'request-storage', 'requests'
    Given param query = '(item.barcode= ' + '05)'
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.requests[0].status == 'Open - Not yet filled'
    * def requestId = $.requests[0].id
    * def existingRequestHoldingId = $.requests[0].holdingsRecordId
    * def existingRequestInstanceId = $.requests[0].instanceId

    * def cancelRequestEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/request/cancel-request-entity-request.json')
    * cancelRequestEntityRequest.cancellationReasonId = cancellationReasonId
    * cancelRequestEntityRequest.cancelledByUserId = extUserId
    * cancelRequestEntityRequest.requesterId = extUserId
    * cancelRequestEntityRequest.requestLevel = 'Item'
    * cancelRequestEntityRequest.requestType = extRequestType
    * cancelRequestEntityRequest.holdingsRecordId = existingRequestHoldingId
    * cancelRequestEntityRequest.instanceId = existingRequestInstanceId
    * cancelRequestEntityRequest.itemId = id1
    * cancelRequestEntityRequest.pickupServicePointId = servicePointId

    Given path 'circulation', 'requests', requestId
    And request cancelRequestEntityRequest
    When method PUT
    Then status 204
    * call pause 5000

    Given path 'circulation', 'requests', requestId
    When method GET
    Then status 200
    And match $.status == 'Closed - Cancelled'

    Given path 'transactions' , transactionId , 'status'
    And retry until response.status == 'CANCELLED'
    When method GET
    Then status 200
    And match $.status == 'CANCELLED'
    And match $.role == 'BORROWING-PICKUP'

  #Negative
  Scenario: Cancel DCB Transaction manually after CLOSED
    * def transactionId = '0G0'
    * def id1 = 'e9b73276-77b6-11ee-b962-0252ac120002'
    * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction-for-borrowing-pickup.feature') { transactionId: '#(transactionId)', extItemId: '#(id1)', itemBarcode: '06' }
    * def updateToCancelRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-cancel.json')
    * def updateToOpenRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-open.json')
    * def updateToCloseRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-close.json')

    * def intCheckInDate = call read('classpath:volaris/mod-dcb/eureka-features/util/get-time-now-function.js')
    * def checkInRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/check-in/check-in-by-barcode-entity-request.json')
    * set checkInRequest.itemBarcode = '06'

    Given path 'circulation', 'check-in-by-barcode'
    And request checkInRequest
    When method POST
    Then status 200
    And match $.item.barcode == '06'
    And match $.item.status.name == 'Awaiting pickup'
    * call pause 5000

    Given path 'transactions' , transactionId , 'status'
    When method GET
    Then status 200
    And match $.status == 'AWAITING_PICKUP'
    And match $.role == 'BORROWING-PICKUP'

    * def checkOutByBarcodeEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/check-out/check-out-by-barcode-entity-request.json')
    * checkOutByBarcodeEntityRequest.userBarcode = extUserBarcode
    * checkOutByBarcodeEntityRequest.itemBarcode = '06'
    * checkOutByBarcodeEntityRequest.servicePointId = servicePointId
    Given path 'circulation', 'check-out-by-barcode'
    And request checkOutByBarcodeEntityRequest
    When method POST
    Then status 201
    * call pause 5000

    Given path 'transactions' , transactionId , 'status'
    When method GET
    Then status 200
    And match $.status == 'ITEM_CHECKED_OUT'
    And match $.role == 'BORROWING-PICKUP'

    * def intCheckInDate = call read('classpath:volaris/mod-dcb/eureka-features/util/get-time-now-function.js')
    * def checkInRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/check-in/check-in-by-barcode-entity-request.json')
    * set checkInRequest.itemBarcode = '06'

    Given path 'circulation', 'check-in-by-barcode'
    And request checkInRequest
    When method POST
    Then status 200
    And match $.item.barcode == '06'
    And match $.item.status.name == 'In transit'
    * call pause 5000

    Given path 'transactions' , transactionId , 'status'
    When method GET
    Then status 200
    And match $.status == 'ITEM_CHECKED_IN'
    And match $.role == 'BORROWING-PICKUP'

    Given path 'transactions' , transactionId , 'status'
    And request updateToCloseRequest
    When method PUT
    Then status 200

    Given path 'transactions' , transactionId , 'status'
    And request updateToCancelRequest
    When method PUT
    Then status 400
    And match $.errors[0].message == 'Cannot cancel transaction dcbTransactionId: 0G0. Transaction already in status: CLOSED: '


# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\cancelling-flow-for-pickup-flow.feature

Feature: Testing Pickup Flow Cancellation

  Background:
    * url baseUrl

    * callonce login testAdmin
    * def okapitokenUser = okapitoken
    * def headersUser = { 'Content-Type': 'application/json', 'x-okapi-token': '#(okapitokenUser)', 'x-okapi-tenant': '#(testTenant)', 'Accept': 'application/json, text/plain'  }
    * configure headers = headersUser
    * callonce variables
    * configure retry = { count: 5, interval: 1000 }

  Scenario: Cancel DCB Transaction manually
    * def transactionId = 'A1'
    * def id1 = 'a9b73276-77b6-11ee-b962-1242ac120003'
    * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction-for-pickup.feature') { transactionId: '#(transactionId)', extItemId: '#(id1)', itemBarcode: 'A1', userId: '#(id1)', barcode: 'A1' }
    * def updateToCancelRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-cancel.json')

    Given path 'transactions' , transactionId , 'status'
    And request updateToCancelRequest
    When method PUT
    Then status 200

    Given path 'transactions' , transactionId , 'status'
    And retry until response.status == 'CANCELLED'
    When method GET
    Then status 200
    And match $.status == 'CANCELLED'
    And match $.role == 'PICKUP'

    Given path 'request-storage', 'requests'
    Given param query = '(item.barcode= ' + 'A1)'
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.requests[0].status == 'Closed - Cancelled'

  Scenario: Cancel DCB Transaction manually after OPEN
    * def transactionId = 'B1'
    * def id1 = 'a9b73276-77b7-11ee-b962-1242ac120003'
    * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction-for-pickup.feature') { transactionId: '#(transactionId)', extItemId: '#(id1)', itemBarcode: 'B1', userId: '#(id1)', barcode: 'B1' }
    * def updateToCancelRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-cancel.json')

    * def updateToOpenRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-open.json')

    Given path 'transactions' , transactionId , 'status'
    And request updateToOpenRequest
    When method PUT
    Then status 200

    Given path 'transactions' , transactionId , 'status'
    When method GET
    Then status 200
    And match $.status == 'OPEN'
    And match $.role == 'PICKUP'

    Given path 'transactions' , transactionId , 'status'
    And request updateToCancelRequest
    When method PUT
    Then status 200


    Given path 'transactions' , transactionId , 'status'
    And retry until response.status == 'CANCELLED'
    When method GET
    Then status 200
    And match $.status == 'CANCELLED'
    And match $.role == 'PICKUP'

    Given path 'request-storage', 'requests'
    Given param query = '(item.barcode= ' + 'B1)'
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.requests[0].status == 'Closed - Cancelled'

  Scenario: Cancel DCB Transaction manually after AWAITING_PICKUP
    * def transactionId = 'C1'
    * def id1 = 'a9b73276-77b8-11ee-b962-1242ac120003'
    * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction-for-pickup.feature') { transactionId: '#(transactionId)', extItemId: '#(id1)', itemBarcode: 'C1', userId: '#(id1)', barcode: 'C1' }
    * def updateToCancelRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-cancel.json')

    * def intCheckInDate = call read('classpath:volaris/mod-dcb/eureka-features/util/get-time-now-function.js')
    * def checkInRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/check-in/check-in-by-barcode-entity-request.json')
    * set checkInRequest.itemBarcode = 'C1'

    Given path 'circulation', 'check-in-by-barcode'
    And request checkInRequest
    When method POST
    Then status 200
    And match $.item.barcode == 'C1'
    And match $.item.status.name == 'Awaiting pickup'
    * call pause 5000

    Given path 'transactions' , transactionId , 'status'
    When method GET
    Then status 200
    And match $.status == 'AWAITING_PICKUP'
    And match $.role == 'PICKUP'

    Given path 'transactions' , transactionId , 'status'
    And request updateToCancelRequest
    When method PUT
    Then status 200

    Given path 'transactions' , transactionId , 'status'
    And retry until response.status == 'CANCELLED'
    When method GET
    Then status 200
    And match $.status == 'CANCELLED'
    And match $.role == 'PICKUP'

    Given path 'request-storage', 'requests'
    Given param query = '(item.barcode= ' + 'C1)'
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.requests[0].status == 'Closed - Cancelled'

  #Negative
  Scenario: Cancel DCB Transaction manually after ITEM_CHECKED_OUT
    * def transactionId = 'D1'
    * def id1 = 'a9b73276-77b8-11ee-b962-1242ac130003'
    * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction-for-pickup.feature') { transactionId: '#(transactionId)', extItemId: '#(id1)', itemBarcode: 'D1', userId: '#(id1)', barcode: 'D1' }
    * def updateToCancelRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-cancel.json')

    * def intCheckInDate = call read('classpath:volaris/mod-dcb/eureka-features/util/get-time-now-function.js')
    * def checkInRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/check-in/check-in-by-barcode-entity-request.json')
    * set checkInRequest.itemBarcode = 'D1'

    Given path 'circulation', 'check-in-by-barcode'
    And request checkInRequest
    When method POST
    Then status 200
    And match $.item.barcode == 'D1'
    * call pause 5000

    Given path 'transactions' , transactionId , 'status'
    When method GET
    Then status 200
    And match $.status == 'AWAITING_PICKUP'
    And match $.role == 'PICKUP'

    * def checkOutByBarcodeEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/check-out/check-out-by-barcode-entity-request.json')
    * checkOutByBarcodeEntityRequest.userBarcode = 'D1'
    * checkOutByBarcodeEntityRequest.itemBarcode = 'D1'
    * checkOutByBarcodeEntityRequest.servicePointId = servicePointId
    Given path 'circulation', 'check-out-by-barcode'
    And request checkOutByBarcodeEntityRequest
    When method POST
    Then status 201
    * call pause 5000

    Given path 'transactions' , transactionId , 'status'
    When method GET
    Then status 200
    And match $.status == 'ITEM_CHECKED_OUT'
    And match $.role == 'PICKUP'

    Given path 'transactions' , transactionId , 'status'
    And request updateToCancelRequest
    When method PUT
    Then status 400
    And match $.errors[0].message == 'Cannot cancel transaction dcbTransactionId: D1. Transaction already in status: ITEM_CHECKED_OUT: '

   #Negative
   Scenario: Cancel DCB Transaction manually after ITEM_CHECKED_IN
     * def transactionId = 'E1'
     * def id1 = 'a9b73276-77b8-11ee-b962-1242bc130003'
     * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction-for-pickup.feature') { transactionId: '#(transactionId)', extItemId: '#(id1)', itemBarcode: 'E1', userId: '#(id1)', barcode: 'E1' }
     * def updateToCancelRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-cancel.json')

     * def intCheckInDate = call read('classpath:volaris/mod-dcb/eureka-features/util/get-time-now-function.js')
     * def checkInRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/check-in/check-in-by-barcode-entity-request.json')
     * set checkInRequest.itemBarcode = 'E1'

     Given path 'circulation', 'check-in-by-barcode'
     And request checkInRequest
     When method POST
     Then status 200
     And match $.item.barcode == 'E1'
     * call pause 5000

     Given path 'transactions' , transactionId , 'status'
     When method GET
     Then status 200
     And match $.status == 'AWAITING_PICKUP'
     And match $.role == 'PICKUP'

     * def checkOutByBarcodeEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/check-out/check-out-by-barcode-entity-request.json')
     * checkOutByBarcodeEntityRequest.userBarcode = 'E1'
     * checkOutByBarcodeEntityRequest.itemBarcode = 'E1'
     * checkOutByBarcodeEntityRequest.servicePointId = servicePointId
     Given path 'circulation', 'check-out-by-barcode'
     And request checkOutByBarcodeEntityRequest
     When method POST
     Then status 201
     * call pause 5000

     Given path 'transactions' , transactionId , 'status'
     When method GET
     Then status 200
     And match $.status == 'ITEM_CHECKED_OUT'
     And match $.role == 'PICKUP'

     Given path 'circulation', 'check-in-by-barcode'
     And request checkInRequest
     When method POST
     Then status 200
     And match $.item.barcode == 'E1'

     Given path 'transactions' , transactionId , 'status'
     And request updateToCancelRequest
     When method PUT
     Then status 400
     And match $.errors[0].message == 'Cannot cancel transaction dcbTransactionId: E1. Transaction already in status: ITEM_CHECKED_IN: '

  Scenario: Cancel DCB Transaction automatically
    * def transactionId = 'F1'
    * def id1 = 'a9b73376-77b6-11ee-b962-1242ac120003'
    * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction-for-pickup.feature') { transactionId: '#(transactionId)', extItemId: '#(id1)', itemBarcode: 'F1', userId: '#(id1)', barcode: 'F1' }

    Given path 'request-storage', 'requests'
    Given param query = '(item.barcode= ' + 'F1)'
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.requests[0].status == 'Open - Not yet filled'
    * def requestId = $.requests[0].id

    * def cancelRequestEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/request/cancel-request-entity-request.json')
    * cancelRequestEntityRequest.cancellationReasonId = cancellationReasonId
    * cancelRequestEntityRequest.cancelledByUserId = id1
    * cancelRequestEntityRequest.requesterId = id1
    * cancelRequestEntityRequest.requestLevel = 'Item'
    * cancelRequestEntityRequest.requestType = extRequestType
    * cancelRequestEntityRequest.holdingsRecordId = holdingId
    * cancelRequestEntityRequest.itemId = id1
    * cancelRequestEntityRequest.pickupServicePointId = servicePointId

    Given path 'circulation', 'requests', requestId
    And request cancelRequestEntityRequest
    When method PUT
    Then status 204
    * call pause 5000

    Given path 'circulation', 'requests', requestId
    When method GET
    Then status 200
    And match $.status == 'Closed - Cancelled'

    Given path 'transactions' , transactionId , 'status'
    When method GET
    Then status 200
    And match $.status == 'CANCELLED'
    And match $.role == 'PICKUP'

  #Negative
  Scenario: Cancel DCB Transaction manually after CLOSED
    * def transactionId = 'G1'
    * def id1 = 'a9b73276-77b8-11ee-b962-2242bc130003'
    * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction-for-pickup.feature') { transactionId: '#(transactionId)', extItemId: '#(id1)', itemBarcode: 'G1', userId: '#(id1)', barcode: 'G1' }
    * def updateToCancelRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-cancel.json')
    * def updateToCloseRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-close.json')

    * def intCheckInDate = call read('classpath:volaris/mod-dcb/eureka-features/util/get-time-now-function.js')
    * def checkInRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/check-in/check-in-by-barcode-entity-request.json')
    * set checkInRequest.itemBarcode = 'G1'

    Given path 'circulation', 'check-in-by-barcode'
    And request checkInRequest
    When method POST
    Then status 200
    And match $.item.barcode == 'G1'
    * call pause 5000

    Given path 'transactions' , transactionId , 'status'
    When method GET
    Then status 200
    And match $.status == 'AWAITING_PICKUP'
    And match $.role == 'PICKUP'

    * def checkOutByBarcodeEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/check-out/check-out-by-barcode-entity-request.json')
    * checkOutByBarcodeEntityRequest.userBarcode = 'G1'
    * checkOutByBarcodeEntityRequest.itemBarcode = 'G1'
    * checkOutByBarcodeEntityRequest.servicePointId = servicePointId
    Given path 'circulation', 'check-out-by-barcode'
    And request checkOutByBarcodeEntityRequest
    When method POST
    Then status 201
    * call pause 5000

    Given path 'transactions' , transactionId , 'status'
    When method GET
    Then status 200
    And match $.status == 'ITEM_CHECKED_OUT'
    And match $.role == 'PICKUP'

    Given path 'circulation', 'check-in-by-barcode'
    And request checkInRequest
    When method POST
    Then status 200
    And match $.item.barcode == 'G1'
    * call pause 5000

    Given path 'transactions' , transactionId , 'status'
    And request updateToCloseRequest
    When method PUT
    Then status 200

    Given path 'transactions' , transactionId , 'status'
    And request updateToCancelRequest
    When method PUT
    Then status 400
    And match $.errors[0].message == 'Cannot cancel transaction dcbTransactionId: G1. Transaction already in status: CLOSED: '



# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\cancelling-lending-flow.feature

Feature: Testing Lending Flow Cancellation

  Background:
    * url baseUrl

    * callonce login testAdmin
    * def okapitokenUser = okapitoken
    * def headersUser = { 'Content-Type': 'application/json', 'x-okapi-token': '#(okapitokenUser)', 'x-okapi-tenant': '#(testTenant)', 'Accept': 'application/json, text/plain'  }
    * configure headers = headersUser
    * callonce variables
    * configure retry = { count: 5, interval: 1000 }

  Scenario: Cancel DCB Transaction manually
    * def transactionId = '010'
    * def id1 = 'a9b73276-77b6-11ee-b962-0242ac120002'
    * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction.feature') { transactionId: '#(transactionId)', extItemId: '#(extItemId1)', itemBarcode: '#(itemBarcode1)' }
    * def updateToCancelRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-cancel.json')

    Given path 'transactions' , transactionId , 'status'
    And request updateToCancelRequest
    When method PUT
    Then status 200

    Given path 'transactions' , transactionId , 'status'
    And retry until response.status == 'CANCELLED'
    When method GET
    Then status 200
    And match $.status == 'CANCELLED'
    And match $.role == 'LENDER'

    Given path 'request-storage', 'requests'
    Given param query = '(item.barcode= ' + itemBarcode1 + ' and itemId = ' + extItemId1 + ' )'
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.requests[0].status == 'Closed - Cancelled'

  Scenario: Cancel DCB Transaction automatically
    * def transactionId = '00'
    * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction.feature') { transactionId: '#(transactionId)', extItemId: '#(extItemId5)', itemBarcode: '#(itemBarcode5)' }

    Given path 'request-storage', 'requests'
    Given param query = '(item.barcode= ' + itemBarcode5 + ' and itemId = ' + extItemId5 + ' )'
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.requests[0].status == 'Open - Not yet filled'
    * def requestId = $.requests[0].id

    * def cancelRequestEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/request/cancel-request-entity-request.json')
    * cancelRequestEntityRequest.cancellationReasonId = cancellationReasonId
    * cancelRequestEntityRequest.cancelledByUserId = patronId
    * cancelRequestEntityRequest.requesterId = patronId
    * cancelRequestEntityRequest.requestLevel = 'Item'
    * cancelRequestEntityRequest.requestType = extRequestType
    * cancelRequestEntityRequest.holdingsRecordId = holdingId
    * cancelRequestEntityRequest.itemId = extItemId5
    * cancelRequestEntityRequest.pickupServicePointId = servicePointId

    Given path 'circulation', 'requests', requestId
    And request cancelRequestEntityRequest
    When method PUT
    Then status 204

    Given path 'circulation', 'requests', requestId
    When method GET
    Then status 200
    And match $.status == 'Closed - Cancelled'
    * call pause 5000

    Given path 'transactions' , transactionId , 'status'
    When method GET
    Then status 200
    And match $.status == 'CANCELLED'
    And match $.role == 'LENDER'

  Scenario: Cancel DCB Transaction manually after OPEN
    * def transactionId = '020'
    * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction.feature') { transactionId: '#(transactionId)', extItemId: '#(extItemId5)', itemBarcode: '#(itemBarcode5)' }
    * def updateToCancelRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-cancel.json')

    * def intCheckInDate = call read('classpath:volaris/mod-dcb/eureka-features/util/get-time-now-function.js')
    * def checkInRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/check-in/check-in-by-barcode-entity-request.json')
    * set checkInRequest.itemBarcode = itemBarcode5

    Given path 'circulation', 'check-in-by-barcode'
    And request checkInRequest
    When method POST
    Then status 200
    And match $.item.barcode == itemBarcode5
    And match $.item.status.name == 'In transit'
    * call pause 5000

    Given path 'transactions' , transactionId , 'status'
    When method GET
    Then status 200
    And match $.status == 'OPEN'
    And match $.role == 'LENDER'

    Given path 'transactions' , transactionId , 'status'
    And request updateToCancelRequest
    When method PUT
    Then status 200

    Given path 'transactions' , transactionId , 'status'
    And retry until response.status == 'CANCELLED'
    When method GET
    Then status 200
    And match $.status == 'CANCELLED'
    And match $.role == 'LENDER'

    Given path 'request-storage', 'requests'
    Given param query = '(item.barcode= ' + itemBarcode5 + ' and itemId = ' + extItemId5 + ' )'
    When method GET
    Then status 200
    And match $.totalRecords == 2
    And match $.requests[0].status == 'Closed - Cancelled'

  Scenario: Cancel DCB Transaction manually after AWAITING_PICKUP

    * def transactionId = '030'
    * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction.feature') { transactionId: '#(transactionId)', extItemId: '#(extItemId2)', itemBarcode: '#(itemBarcode2)' }
    * def updateToCancelRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-cancel.json')

    * def intCheckInDate = call read('classpath:volaris/mod-dcb/eureka-features/util/get-time-now-function.js')
    * def checkInRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/check-in/check-in-by-barcode-entity-request.json')
    * set checkInRequest.itemBarcode = itemBarcode2

    Given path 'circulation', 'check-in-by-barcode'
    And request checkInRequest
    When method POST
    Then status 200
    And match $.item.barcode == itemBarcode2
    And match $.item.status.name == 'In transit'

    * def updateToAwaitingPickupRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-awaiting-pickup.json')

    Given path 'transactions' , transactionId , 'status'
    And request updateToAwaitingPickupRequest
    When method PUT
    Then status 200

    Given path 'transactions' , transactionId , 'status'
    When method GET
    Then status 200
    And match $.status == 'AWAITING_PICKUP'
    And match $.role == 'LENDER'

    Given path 'transactions' , transactionId , 'status'
    And request updateToCancelRequest
    When method PUT
    Then status 200

    Given path 'transactions' , transactionId , 'status'
    And retry until response.status == 'CANCELLED'
    When method GET
    Then status 200
    And match $.status == 'CANCELLED'
    And match $.role == 'LENDER'

    Given path 'request-storage', 'requests'
    Given param query = '(item.barcode= ' + itemBarcode2 + ' and itemId = ' + extItemId2 + ' )'
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.requests[0].status == 'Closed - Cancelled'

  #Negative
  Scenario: Cancel DCB Transaction manually after ITEM_CHECKED_OUT
    * def transactionId = '040'
    * def itemId = 'c7a2f4de-77af-11ee-b962-0242ac120002'
    * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction.feature') { transactionId: '#(transactionId)', extItemId: '#(extItemId3)', itemBarcode: '#(itemBarcode3)' }
    * def updateToCancelRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-cancel.json')

    * def intCheckInDate = call read('classpath:volaris/mod-dcb/eureka-features/util/get-time-now-function.js')
    * def checkInRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/check-in/check-in-by-barcode-entity-request.json')
    * set checkInRequest.itemBarcode = itemBarcode3


    Given path 'circulation', 'check-in-by-barcode'
    And request checkInRequest
    When method POST
    Then status 200
    And match $.item.barcode == itemBarcode3
    And match $.item.status.name == 'In transit'
    * call pause 5000

    * def updateToAwaitingPickupRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-awaiting-pickup.json')

    Given path 'transactions' , transactionId , 'status'
    And request updateToAwaitingPickupRequest
    When method PUT
    Then status 200

    * def updateToCheckOutRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-item-check-out.json')

    Given path 'transactions' , transactionId , 'status'
    And request updateToCheckOutRequest
    When method PUT
    Then status 200

    Given path 'transactions' , transactionId , 'status'
    When method GET
    Then status 200
    And match $.status == 'ITEM_CHECKED_OUT'
    And match $.role == 'LENDER'

    Given path 'transactions' , transactionId , 'status'
    And request updateToCancelRequest
    When method PUT
    Then status 400
    And match $.errors[0].message == 'Cannot cancel transaction dcbTransactionId: 040. Transaction already in status: ITEM_CHECKED_OUT: '

  #Negative
  Scenario: Cancel DCB Transaction manually after ITEM_CHECKED_IN
    * def transactionId = '050'
    * def itemId = 'c7a2f4de-78af-11ee-b962-0242ac120002'
    * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction.feature') { transactionId: '#(transactionId)', extItemId: '#(extItemId4)', itemBarcode: '#(itemBarcode4)' }
    * def updateToCancelRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-cancel.json')

    * def intCheckInDate = call read('classpath:volaris/mod-dcb/eureka-features/util/get-time-now-function.js')
    * def checkInRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/check-in/check-in-by-barcode-entity-request.json')
    * set checkInRequest.itemBarcode = itemBarcode4


    Given path 'circulation', 'check-in-by-barcode'
    And request checkInRequest
    When method POST
    Then status 200
    And match $.item.barcode == itemBarcode4
    And match $.item.status.name == 'In transit'
    * call pause 5000

    * def updateToAwaitingPickupRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-awaiting-pickup.json')

    Given path 'transactions' , transactionId , 'status'
    And request updateToAwaitingPickupRequest
    When method PUT
    Then status 200

    * def updateToCheckOutRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-item-check-out.json')

    Given path 'transactions' , transactionId , 'status'
    And request updateToCheckOutRequest
    When method PUT
    Then status 200

    Given path 'transactions' , transactionId , 'status'
    When method GET
    Then status 200
    And match $.status == 'ITEM_CHECKED_OUT'
    And match $.role == 'LENDER'

    Given path 'circulation', 'check-in-by-barcode'
    And request checkInRequest
    When method POST
    Then status 200
    And match $.item.barcode == itemBarcode4
    And match $.item.status.name == 'Available'

    Given path 'transactions' , transactionId , 'status'
    And request updateToCancelRequest
    When method PUT
    Then status 400
    And match $.errors[0].message == 'Cannot cancel transaction dcbTransactionId: 050. Transaction already in status: CLOSED: '


# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\create-circulation-request.feature

Feature: Testing Create circulation request

  Background:
    * url baseUrl

    * callonce login testUser
    * def okapitokenUser = okapitoken
    * def headersUser = { 'Content-Type': 'application/json', 'x-okapi-token': '#(okapitokenUser)', 'x-okapi-tenant': '#(testTenant)', 'Accept': 'application/json'  }
    * configure headers = headersUser

  Scenario: Create circulation request
    * def dcbTransactionId = '123456891'

    Given path '/transactions/' + dcbTransactionId
    And request
    """
    {
      "item": {
        "id": "e2325f58-e757-43c6-a761-de634f075f71",
        "title": "Test",
        "barcode": "newdcb123",
        "pickupLocation": "Datalogisk Institut",
        "materialType": "book",
        "lendingLibraryCode": "KU"
    },
      "patron": {
          "id": "7e905a99-11ba-47b1-9d13-da0f0b108212",
          "group": "staff",
          "barcode": "11111",
          "borrowingLibraryCode": "E"
     },
    "role": "LENDER"
    }
    """
    When method POST
    Then status 201






# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\get-transaction-status-by-id.feature

Feature: Testing Get DCB Transaction Status By Id

  Background:
    * url baseUrl

    * callonce login testUser
    * def okapitokenUser = okapitoken
    * def headersUser = { 'Content-Type': 'application/json', 'x-okapi-token': '#(okapitokenUser)', 'x-okapi-tenant': '#(testTenant)', 'Accept': 'application/json'  }
    * configure headers = headersUser

  Scenario: Get DCB Transaction Status By transaction Id
    * def dcbTransactionId = '123456891'

    Given path '/transactions/' + dcbTransactionId + '/status'
    When method GET
    Then status 200
    And match response.status == 'CLOSED'

  Scenario: Get DCB Transaction Status with incorrect transaction id
    * def dcbTransactionId = '123456891'

    Given url edgeUrl
    Given path '/transactions/' + dcbTransactionId + '/status'
    When method GET
    Then status 404
    And def responseJson = response
    And karate.set('responseJson.errors[0].message','DCB Transaction was not found by id= '+dcbTransactionId)
    And match response == responseJson




# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\lending-flow-chain-of-responsibility.feature

Feature: Testing Lending Flow chain of Responsibility

  Background:
    * url baseUrl
    * def proxyCall = karate.get('proxyCall', false)
    * def user = proxyCall == true ? admin : testAdmin
    * print 'user  is', user
    * callonce login user
    * def okapitokenUser = okapitoken
    * def headersUser = { 'Content-Type': 'application/json', 'x-okapi-token': '#(okapitokenUser)', 'x-okapi-tenant': '#(testTenant)', 'Accept': 'application/json'  }
    * configure headers = headersUser
    * callonce variables


  Scenario: Create and Update DCB Transaction from OPEN to ITEM_CHECKED_OUT
    * def transactionId = '04040'
    * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction.feature') { transactionId: '#(transactionId)', extItemId: '#(itemId51)', itemBarcode: '#(itemBarcode51)' }
    * def intCheckInDate = call read('classpath:volaris/mod-dcb/eureka-features/util/get-time-now-function.js')
    * def checkInRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/check-in/check-in-by-barcode-entity-request.json')
    * checkInRequest.servicePointId = servicePointId11
    * checkInRequest.itemBarcode = itemBarcode51

    Given path 'circulation', 'check-in-by-barcode'
    And request checkInRequest
    When method POST
    Then status 200
    And match $.item.barcode == itemBarcode51
    And match $.item.status.name == 'In transit'
    * call pause 5000

    Given path '/transactions/' + transactionId + '/status'
    When method GET
    Then status 200
    And match $.status == 'OPEN'
    And match $.role == 'LENDER'

    * def updateToCheckOutRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-item-check-out.json')

    Given path '/transactions/' + transactionId + '/status'
    And request updateToCheckOutRequest
    When method PUT
    Then status 200
    And match $.status == 'ITEM_CHECKED_OUT'

  Scenario: Create and Update DCB Transaction from OPEN to ITEM_CHECKED_IN
    * def transactionId = '04041'
    * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction.feature') { transactionId: '#(transactionId)', extItemId: '#(itemId61)', itemBarcode: '#(itemBarcode61)' }
    * def intCheckInDate = call read('classpath:volaris/mod-dcb/eureka-features/util/get-time-now-function.js')
    * def checkInRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/check-in/check-in-by-barcode-entity-request.json')
    * checkInRequest.servicePointId = servicePointId11
    * checkInRequest.itemBarcode = itemBarcode61

    Given path 'circulation', 'check-in-by-barcode'
    And request checkInRequest
    When method POST
    Then status 200
    And match $.item.barcode == itemBarcode61
    And match $.item.status.name == 'In transit'
    * call pause 5000

    Given path '/transactions/' + transactionId + '/status'
    When method GET
    Then status 200
    And match $.status == 'OPEN'
    And match $.role == 'LENDER'

    * def updateToCheckInRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-item-check-in.json')

    Given path '/transactions/' + transactionId + '/status'
    And request updateToCheckInRequest
    When method PUT
    Then status 200
    And match $.status == 'ITEM_CHECKED_IN'

  Scenario: Create and Update DCB Transaction from AWAITING_PICKUP to ITEM_CHECKED_IN
    * def transactionId = '04042'
    * def createTransaction = call read('classpath:volaris/mod-dcb/eureka-reusable/create-dcb-transaction.feature') { transactionId: '#(transactionId)', extItemId: '#(itemId71)', itemBarcode: '#(itemBarcode71)' }
    * def intCheckInDate = call read('classpath:volaris/mod-dcb/eureka-features/util/get-time-now-function.js')
    * def checkInRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/check-in/check-in-by-barcode-entity-request.json')
    * checkInRequest.servicePointId = servicePointId11
    * checkInRequest.itemBarcode = itemBarcode71

    Given path 'circulation', 'check-in-by-barcode'
    And request checkInRequest
    When method POST
    Then status 200
    And match $.item.barcode == itemBarcode71
    And match $.item.status.name == 'In transit'
    * call pause 5000

    * def updateToAwaitingPickupRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-awaiting-pickup.json')

    Given path '/transactions/' + transactionId + '/status'
    And request updateToAwaitingPickupRequest
    When method PUT
    Then status 200
    And match $.status == 'AWAITING_PICKUP'

    * def updateToCheckInRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-item-check-in.json')

    Given path '/transactions/' + transactionId + '/status'
    And request updateToCheckInRequest
    When method PUT
    Then status 200
    And match $.status == 'ITEM_CHECKED_IN'

# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\lending-flow.feature

Feature: Testing Lending Flow

  Background:
    * url baseUrl
    * def proxyCall = karate.get('proxyCall', false)
    * def user = proxyCall == true ? testUser : testAdmin
    * print 'user  is', user
    * callonce login user
    * def okapitokenUser = okapitoken
    * def headersUser = { 'Content-Type': 'application/json', 'x-okapi-token': '#(okapitokenUser)', 'x-okapi-tenant': '#(testTenant)', 'Accept': 'application/json'  }
    * def key = ''
    * configure headers = headersUser
    * callonce read('classpath:volaris/mod-dcb/eureka-global/variables.feature')
    * def startDate = callonce getCurrentUtcDate

  Scenario: Validation. Item needs to be present in inventory.(Real item)

    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def createDCBTransactionRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/create-dcb-transaction.json')
    * createDCBTransactionRequest.item.id = itemIdNotExisting
    * def orgPath = '/transactions/' + dcbTransactionId511
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    And request createDCBTransactionRequest
    When method POST
    Then status 404
    And match $.errors[0].message == 'Unable to find existing item with id ' + itemIdNotExisting + ' and barcode ' + itemBarcode + '.'
    And match $.errors[0].code == 'NOT_FOUND_ERROR'

  Scenario: Validation. Patron group should be validated at the time of user creation.

    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def createDCBTransactionRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/create-dcb-transaction.json')
    * createDCBTransactionRequest.patron.id = patronIdNonExisting
    * createDCBTransactionRequest.patron.group = patronNameNonExisting
    * def orgPath = '/transactions/' + dcbTransactionId611
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    And request createDCBTransactionRequest
    When method POST
    Then status 404
    And match $.errors[0].message == 'Patron group not found with name '+patronNameNonExisting + ' '
    And match $.errors[0].code == 'NOT_FOUND_ERROR'

  @CreateDCBTransaction
  Scenario: Create DCB Transaction
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def createDCBTransactionRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/create-dcb-transaction.json')
    * createDCBTransactionRequest.item.id = itemId11
    * createDCBTransactionRequest.item.barcode = itemBarcode11
    * createDCBTransactionRequest.patron.id = patronId11
    * createDCBTransactionRequest.patron.barcode = patronBarcode11
    * createDCBTransactionRequest.patron.group = patronGroupName
    * createDCBTransactionRequest.pickup.servicePointName = 'lending_sp1'
    * createDCBTransactionRequest.pickup.libraryCode = '6uclv'
    * createDCBTransactionRequest.role = 'LENDER'

    * def orgPath = '/transactions/' + dcbTransactionId11
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    And request createDCBTransactionRequest
    When method POST
    Then status 201
    And match $.status == 'CREATED'
    And match $.item.id == itemId11
    And match $.patron.id == patronId11

    * print 'Get servicePoint details'

    * url baseUrl
    * def servicePointName = 'DCB_'+createDCBTransactionRequest.pickup.libraryCode+'_'+createDCBTransactionRequest.pickup.servicePointName
    Given path 'service-points'
    Given param query = '(name= ' + servicePointName + ')'
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.servicepoints[0].name == servicePointName
    * def servicePointId = $.servicepoints[0].id

    * print 'Get request by barcode and item ID after creating dcb transaction'

    Given path 'request-storage', 'requests'
    Given param query = '(item.barcode= ' + itemBarcode11 + ' and itemId = ' + itemId11 + ' )'
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.requests[0].status == 'Open - Not yet filled'
    And match $.requests[0].pickupServicePointId == servicePointId

    * print 'creating another transaction and verify the request ServicePointId'

    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def createDCBTransactionRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/create-dcb-transaction.json')
    * createDCBTransactionRequest.item.id = itemId112
    * createDCBTransactionRequest.item.barcode = itemBarcode112
    * createDCBTransactionRequest.patron.id = patronId11
    * createDCBTransactionRequest.patron.barcode = patronBarcode11
    * createDCBTransactionRequest.patron.group = patronGroupName
    * createDCBTransactionRequest.pickup.servicePointName = 'lending_sp1'
    * createDCBTransactionRequest.pickup.libraryCode = '6uclv'
    * createDCBTransactionRequest.role = 'LENDER'

    * def orgPath = '/transactions/' + itemBarcode112
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    And request createDCBTransactionRequest
    When method POST
    Then status 201
    And match $.status == 'CREATED'

    * url baseUrl
    Given path 'request-storage', 'requests'
    Given param query = '(item.barcode= ' + itemBarcode112 + ' and itemId = ' + itemId112 + ' )'
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.requests[0].status == 'Open - Not yet filled'
    And match $.requests[0].pickupServicePointId == servicePointId

  Scenario: Validation. TransactionId should be unique for every transaction or else it will throw error.

    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def createDCBTransactionRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/create-dcb-transaction.json')
    * createDCBTransactionRequest.item.id = itemId11
    * createDCBTransactionRequest.item.barcode = itemBarcode11
    * createDCBTransactionRequest.patron.id = patronId11
    * createDCBTransactionRequest.patron.barcode = patronBarcode11
    * createDCBTransactionRequest.patron.group = patronGroupName
    * createDCBTransactionRequest.pickup.servicePointId = servicePointId21
    * createDCBTransactionRequest.pickup.servicePointName = servicePointName21

    * createDCBTransactionRequest.role = 'LENDER'

    * def orgPath = '/transactions/' + dcbTransactionId11
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    And request createDCBTransactionRequest
    When method POST
    Then status 409
    And match $.errors[0].message == 'unable to create transaction with id '+ dcbTransactionId11 +' as it already exists'
    And match $.errors[0].code == 'DUPLICATE_ERROR'

  Scenario: Get Item status after creating dcb transaction

    Given path 'item-storage', 'items', itemId11
    When method GET
    Then status 200
    And match $.barcode == itemBarcode11
    And match $.status.name == 'Paged'


  Scenario: Get User Type  after creating dcb transaction. Validation. If the userId and barcode is not exist already, new user with type DCB will be created

    Given path '/users/' + patronId11
    When method GET
    Then status 200
    And match $.barcode == patronBarcode11
    And match $.type == 'dcb'

  Scenario: Validation. If it is a existing user and type is not dcb or shadow, error will be thrown.

    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def createDCBTransactionRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/create-dcb-transaction.json')
    * createDCBTransactionRequest.item.id = itemId110
    * createDCBTransactionRequest.item.barcode = itemBarcode110
    * createDCBTransactionRequest.patron.id = patronId110
    * createDCBTransactionRequest.patron.barcode = patronBarcode110
    * createDCBTransactionRequest.patron.group = patronGroupName
    * createDCBTransactionRequest.pickup.servicePointId = servicePointId21
    * createDCBTransactionRequest.pickup.servicePointName = servicePointName21

    * createDCBTransactionRequest.role = 'LENDER'

    * def orgPath = '/transactions/' + dcbTransactionId51
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    And request createDCBTransactionRequest
    When method POST
    Then status 400
    And match $.errors[0].message == 'User with type patron is retrieved. so unable to create transaction'

  Scenario: Get loan by item ID after creating dcb transaction

    Given path 'loan-storage', 'loans'
    Given param query = '( itemId = ' + itemId11 + ' )'
    When method GET
    Then status 200
    And match $.totalRecords == 0

  @GetTransactionStatusAfterCreatingDCBTransaction
  Scenario: Check Transaction status after creating dcb transaction
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/' + dcbTransactionId11 + '/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    When method GET
    Then status 200
    And match $.status == 'CREATED'
    And match $.role == 'LENDER'

  Scenario: Check Transaction status after creating non-existing dcb transaction status.

    Given path 'transactions' , dcbTransactionIdNonExisting , 'status'
    When method GET
    Then status 404
    And match $.errors[0].message == 'DCB Transaction was not found by id= 123 '
    And match $.errors[0].code == 'NOT_FOUND_ERROR'

  @CheckIn1
  Scenario: current item check-in record and its status
    * def intCheckInDate = call read('classpath:volaris/mod-dcb/eureka-features/util/get-time-now-function.js')
    * def checkInRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/check-in/check-in-by-barcode-entity-request.json')
    * checkInRequest.servicePointId = servicePointId11
    * checkInRequest.itemBarcode = itemBarcode11
    Given path 'circulation', 'check-in-by-barcode'
    And request checkInRequest
    When method POST
    Then status 200
    And match $.item.barcode == itemBarcode11
    And match $.item.status.name == 'In transit'
    * call pause 5000

  Scenario: current item check-in with non-existing barcode item
    * def intCheckInDate = call read('classpath:volaris/mod-dcb/eureka-features/util/get-time-now-function.js')
    * def checkInRequest2 = read('classpath:volaris/mod-dcb/eureka-features/samples/check-in/check-in-by-non-existing-barcode-entity-request.json')

    Given path 'circulation', 'check-in-by-barcode'
    And request checkInRequest2
    When method POST
    Then status 422
    And match $.errors[0].message == 'No item with barcode ' + itemNonExistingBarcode + ' exists'


  Scenario: Get request by barcode and item ID after manual check in

    Given path 'request-storage', 'requests'
    Given param query = '(item.barcode= ' + itemBarcode11 + ' and itemId = ' + itemId11 + ' )'
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.requests[0].status == 'Open - In transit'


  Scenario: Get loan by item ID after manual check in

    Given path 'loan-storage', 'loans'
    Given param query = '( itemId = ' + itemId11 + ' )'
    When method GET
    Then status 200
    And match $.totalRecords == 0

  @GetTransactionStatusAfterCheckIn1
  Scenario: Check Transaction status after manual check in
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/' + dcbTransactionId11 + '/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    When method GET
    Then status 200
    And match $.status == 'OPEN'
    And match $.role == 'LENDER'

  @GetTransactionStatusListAfterOpen
  Scenario: Get Transaction status list after Open
    * def endDate = call getCurrentUtcDate
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath
    Given path newPath
    And param apikey = key
    And param fromDate = proxyCall == true ? proxyStartDate : startDate
    And param toDate = endDate
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.maximumPageNumber == 0
    And match response.transactions[0].id == dcbTransactionId11
    And match response.transactions[0].status == 'OPEN'

  @UpdateTransactionStatusToAwaitingPickup
  Scenario: Update DCB transaction status to AWAITING_PICKUP.
    * def updateToAwaitingPickupRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-awaiting-pickup.json')
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/' + dcbTransactionId11 + '/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    And request updateToAwaitingPickupRequest
    When method PUT
    Then status 200
    * call pause 5000

  Scenario: Get request by barcode and item ID after updating it to AWAITING_PICKUP

    Given path 'request-storage', 'requests'
    Given param query = '(item.barcode= ' + itemBarcode11 + ' and itemId = ' + itemId11 + ' )'
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.requests[0].status == 'Open - Awaiting pickup'

  Scenario: Get loan by item ID after updating it to AWAITING_PICKUP

    Given path 'loan-storage', 'loans'
    Given param query = '( itemId = ' + itemId11 + ' )'
    When method GET
    Then status 200
    And match $.totalRecords == 0

  Scenario: Get Item status after updating it to AWAITING_PICKUP

    Given path 'item-storage', 'items', itemId11
    When method GET
    Then status 200
    And match $.barcode == itemBarcode11
    And match $.status.name == 'Awaiting pickup'

  @GetTransactionStatusAfterUpdatingToAwaitingPickup
  Scenario: Check Transaction status after updating it to AWAITING_PICKUP
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/' + dcbTransactionId11 + '/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    When method GET
    Then status 200
    And match $.status == 'AWAITING_PICKUP'
    And match $.role == 'LENDER'

  @GetTransactionStatusListAfterAwaitingPickup
  Scenario: Get Transaction status list after Awaiting pickup
    * def endDate = call getCurrentUtcDate
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath
    Given path newPath
    And param apikey = key
    And param fromDate = proxyCall == true ? proxyStartDate : startDate
    And param toDate = endDate
    When method GET
    Then status 200
    And match $.totalRecords == 2
    And match $.maximumPageNumber == 0
    And match response.transactions[0].id == dcbTransactionId11
    And match response.transactions[1].id == dcbTransactionId11
    And match response.transactions[0].status == 'OPEN'
    And match response.transactions[1].status == 'AWAITING_PICKUP'

  @UpdateTransactionStatusToItemCheckedOut
  Scenario: Update DCB transaction status to ITEM_CHECKED_OUT
    * def updateToCheckOutRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-item-check-out.json')
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/' + dcbTransactionId11 + '/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    And request updateToCheckOutRequest
    When method PUT
    Then status 200

  Scenario: Update DCB transaction status to ITEM_CHECKED_OUT. Second time the same status.
    * def updateToCheckOutRequest = read('samples/transaction/update-dcb-transaction-to-item-check-out.json')

    Given path 'transactions' , dcbTransactionId11 , 'status'
    And request updateToCheckOutRequest
    When method PUT
    Then status 400
    And match $.errors[0].message == 'Current transaction status equal to new transaction status: dcbTransactionId: 1234, status: ITEM_CHECKED_OUT'
    And match $.errors[0].code == 'VALIDATION_ERROR'

  Scenario: Get request by barcode and item ID after updating it to ITEM_CHECKED_OUT

    Given path 'request-storage', 'requests'
    Given param query = '(item.barcode= ' + itemBarcode11 + ' and itemId = ' + itemId11 + ' )'
    When method GET
    Then status 200
    And match $.requests[0].status == 'Closed - Filled'
    And match $.totalRecords == 1

  Scenario: Get loan by item ID after updating it to ITEM_CHECKED_OUT

    Given path 'loan-storage', 'loans'
    Given param query = '( itemId = ' + itemId11 + ' )'
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.loans[0].userId == patronId11


  Scenario: Get Item status after updating it to ITEM_CHECKED_OUT

    Given path 'item-storage', 'items', itemId11
    When method GET
    Then status 200
    And match $.barcode == itemBarcode11
    And match $.status.name == 'Checked out'

  @GetTransactionStatusAfterUpdatingToItemCheckedOut
  Scenario: Check Transaction status after updating it to ITEM_CHECKED_OUT
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/' + dcbTransactionId11 + '/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    When method GET
    Then status 200
    And match $.status == 'ITEM_CHECKED_OUT'
    And match $.role == 'LENDER'

  @GetTransactionStatusListAfterItemCheckedOut
  Scenario: Get Transaction status list after Item checked out
    * def endDate = call getCurrentUtcDate
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath
    Given path newPath
    And param apikey = key
    And param fromDate = proxyCall == true ? proxyStartDate : startDate
    And param toDate = endDate
    When method GET
    Then status 200
    And match $.totalRecords == 3
    And match $.maximumPageNumber == 0
    And match response.transactions[0].id == dcbTransactionId11
    And match response.transactions[1].id == dcbTransactionId11
    And match response.transactions[2].id == dcbTransactionId11
    And match response.transactions[0].status == 'OPEN'
    And match response.transactions[1].status == 'AWAITING_PICKUP'
    And match response.transactions[2].status == 'ITEM_CHECKED_OUT'

  @UpdateTransactionStatusToItemCheckedIn
  Scenario: Update DCB transaction status to ITEM_CHECKED_IN
    * def updateToCheckInRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-item-check-in.json')
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/' + dcbTransactionId11 + '/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    And request updateToCheckInRequest
    When method PUT
    Then status 200

  @GetTransactionStatusAfterUpdatingToItemCheckedIn
  Scenario: Check Transaction status after updating it to ITEM_CHECKED_IN
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/' + dcbTransactionId11 + '/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    When method GET
    Then status 200
    And match $.status == 'ITEM_CHECKED_IN'
    And match $.role == 'LENDER'

  @GetTransactionStatusListAfterItemCheckedIn
  Scenario: Get Transaction status list after Item checked in
    * def endDate = call getCurrentUtcDate
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath
    Given path newPath
    And param apikey = key
    And param fromDate = proxyCall == true ? proxyStartDate : startDate
    And param toDate = endDate
    And param pageSize = 3
    And param pageNumber = 1
    When method GET
    Then status 200
    And match $.totalRecords == 4
    And match $.maximumPageNumber == 1
    And match response.transactions[0].id == dcbTransactionId11
    And match response.transactions[0].status == 'ITEM_CHECKED_IN'

  Scenario: Get Item status after updating it to ITEM_CHECKED_IN

    Given path 'item-storage', 'items', itemId11
    When method GET
    Then status 200
    And match $.barcode == itemBarcode11
    And match $.status.name == 'Checked out'

  @CheckIn2
  Scenario: current item check-in record and its status
    * def intCheckInDate = call read('classpath:volaris/mod-dcb/eureka-features/util/get-time-now-function.js')
    * def checkInRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/check-in/check-in-by-barcode-entity-request.json')
    * checkInRequest.servicePointId = servicePointId11
    * checkInRequest.itemBarcode = itemBarcode11

    Given path 'circulation', 'check-in-by-barcode'
    And request checkInRequest
    When method POST
    Then status 200
    And match $.item.barcode == itemBarcode11
#    And match $.item.status.name == 'Available'
    * call pause 5000

  @GetTransactionStatusAfterCheckIn2
  Scenario: Check Transaction status after manual check in
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/' + dcbTransactionId11 + '/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    When method GET
    Then status 200
    And match $.status == 'CLOSED'
    And match $.role == 'LENDER'

  @GetTransactionStatusListAfterClosed
  Scenario: Get Transaction status list after Closed
    * def endDate = call getCurrentUtcDate
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath
    Given path newPath
    And param apikey = key
    And param fromDate = proxyCall == true ? proxyStartDate : startDate
    And param toDate = endDate
    And param pageSize = 2
    And param pageNumber = 1
    When method GET
    Then status 200
    And match $.totalRecords == 5
    And match $.maximumPageNumber == 2
    And match response.transactions[0].id == dcbTransactionId11
    And match response.transactions[1].id == dcbTransactionId11
    And match response.transactions[0].status == 'ITEM_CHECKED_OUT'
    And match response.transactions[1].status == 'ITEM_CHECKED_IN'


# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\pickup-flow.feature

Feature: Pickup Flow Scenarios

  Background:
    * url baseUrl
    * def proxyCall = karate.get('proxyCall', false)
    * def user = proxyCall == true ? testUser : testAdmin
    * print 'user  is', user
    * callonce login user
    * def okapitokenUser = okapitoken
    * def headersUser = { 'Content-Type': 'application/json', 'x-okapi-token': '#(okapitokenUser)', 'x-okapi-tenant': '#(testTenant)', 'Accept': 'application/json'  }
    * def key = ''
    * configure headers = headersUser
    * callonce variables
    * def startDate = callonce getCurrentUtcDate

  Scenario: Validation. Patron group should be validated at the time of user creation.

    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def createDCBTransactionRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/create-dcb-transaction.json')
    * createDCBTransactionRequest.item.id = itemId80
    * createDCBTransactionRequest.item.barcode = itemBarcode80
    #
    * createDCBTransactionRequest.patron.id = patronIdNonExisting
    * createDCBTransactionRequest.patron.group = patronNameNonExisting
    * createDCBTransactionRequest.pickup.servicePointId = servicePointId21
    * createDCBTransactionRequest.pickup.servicePointName = servicePointName21
    * createDCBTransactionRequest.role = 'PICKUP'

    * def orgPath = '/transactions/' + dcbTransactionIdValidation12
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    And request createDCBTransactionRequest
    When method POST
    Then status 404
    And match $.errors[0].message == 'Patron group not found with name '+patronNameNonExisting + ' '
    And match $.errors[0].code == 'NOT_FOUND_ERROR'

  Scenario: Validation. If the item barcode is already present in the inventory, error will be thrown.

    # create item with Barcode itemBarcodeAlreadyExists3
    * def materialTypeEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/item/material-type-entity-request.json')
    * materialTypeEntityRequest.id = intMaterialTypeId3
    * materialTypeEntityRequest.name = intMaterialTypeName3
    Given path 'material-types'
    And request materialTypeEntityRequest
    When method POST
    Then status 201

    # create item with barcode itemBarcodeAlreadyExists3
    * def itemEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/item/item-entity-request.json')
    * itemEntityRequest.barcode = itemBarcodeAlreadyExists3
    * itemEntityRequest.id = itemId7
    * itemEntityRequest.materialType.id = intMaterialTypeId3
    * itemEntityRequest.status.name = 'Available'

    Given path 'inventory', 'items'
    And request itemEntityRequest
    When method POST
    Then status 201

     # create Transaction with itemBarcodeAlreadyExists3
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def createDCBTransactionRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/create-dcb-transaction.json')
    * createDCBTransactionRequest.item.id = itemId7
    # item with existing barcode itemBarcodeAlreadyExists3
    * createDCBTransactionRequest.item.barcode = itemBarcodeAlreadyExists3
    * createDCBTransactionRequest.patron.id = patronId3
    * createDCBTransactionRequest.patron.barcode = patronBarcode3
    * createDCBTransactionRequest.pickup.servicePointId = servicePointId21
    * createDCBTransactionRequest.pickup.servicePointName = servicePointName21
    * createDCBTransactionRequest.role = 'PICKUP'

    * def orgPath = '/transactions/' + dcbTransactionIdValidation20
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    And request createDCBTransactionRequest
    When method POST
    Then status 409
    And match $.errors[0].message == 'Unable to create item with barcode ' + itemBarcodeAlreadyExists3 + ' as it exists in inventory '

  Scenario: Validation. If item is not present in inventory, new virtual item will be created.

    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def createDCBTransactionRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/create-dcb-transaction.json')
    # item with id itemId60 and itemBarcode60 will be created automatically
    * createDCBTransactionRequest.item.id = itemId60
    * createDCBTransactionRequest.item.barcode = itemBarcode60
    * createDCBTransactionRequest.patron.id = patronId3
    * createDCBTransactionRequest.patron.barcode = patronBarcode3
    * createDCBTransactionRequest.pickup.servicePointId = servicePointId21
    * createDCBTransactionRequest.pickup.servicePointName = servicePointName21
    * createDCBTransactionRequest.role = 'PICKUP'

    * def orgPath = '/transactions/' + dcbTransactionIdValidation10
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    And request createDCBTransactionRequest
    When method POST
    Then status 201
    And match $.status == 'CREATED'

    Given path 'request-storage', 'requests'
    Given param query = '(item.barcode= ' + itemBarcode60 + ')'
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.requests[0].status == 'Open - Not yet filled'
    * def requestId = $.requests[0].id

    # Cancel transaction in order to reuse the same item id and item barcode.
    * def cancelRequestEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/request/cancel-request-entity-request.json')
    * cancelRequestEntityRequest.cancellationReasonId = cancellationReasonId
    * cancelRequestEntityRequest.cancelledByUserId = patronId3
    * cancelRequestEntityRequest.requesterId = patronId3
    * cancelRequestEntityRequest.requestLevel = 'Item'
    * cancelRequestEntityRequest.requestType = extRequestType
    * cancelRequestEntityRequest.holdingsRecordId = holdingId
    * cancelRequestEntityRequest.itemId = itemId60
    * cancelRequestEntityRequest.pickupServicePointId = servicePointId21

    Given path 'circulation', 'requests', requestId
    And request cancelRequestEntityRequest
    When method PUT
    Then status 204

    Given path 'circulation', 'requests', requestId
    When method GET
    Then status 200
    And match $.status == 'Closed - Cancelled'

    Given path 'transactions' , dcbTransactionIdValidation10 , 'status'
    When method GET
    Then status 200
    And match $.status == 'CANCELLED'
    And match $.role == 'PICKUP'

  @GetTransactionStatusListAfterCancelled
  Scenario: Get Transaction status list after Cancelled
    * def endDate = call getCurrentUtcDate
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath
    Given path newPath
    And param apikey = key
    And param fromDate = startDate
    And param toDate = endDate
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.maximumPageNumber == 0
    And match response.transactions[0].id == dcbTransactionIdValidation10
    And match response.transactions[0].status == 'CANCELLED'

  Scenario: Validation. If virtual item already exists, it will be reused. Make sure same id and barcode should be used. itemId2 reused

    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def createDCBTransactionRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/create-dcb-transaction.json')
    # item with id itemId60 and itemBarcode60 will be created automatically
    * createDCBTransactionRequest.item.id = itemId60
    * createDCBTransactionRequest.item.barcode = itemBarcode60
    * createDCBTransactionRequest.patron.id = patronId3
    * createDCBTransactionRequest.patron.barcode = patronBarcode3
    * createDCBTransactionRequest.pickup.servicePointId = servicePointId21
    * createDCBTransactionRequest.pickup.servicePointName = servicePointName21
    * createDCBTransactionRequest.role = 'PICKUP'

    * def orgPath = '/transactions/' + dcbTransactionIdValidation11
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    And request createDCBTransactionRequest
    When method POST
    Then status 201
    And match $.status == 'CREATED'

  Scenario: Validation. Material type in the request should be present in inventory or else error will be thrown.

    # create item with not existing material type
    * def itemEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/item/item-entity-request.json')
    * itemEntityRequest.barcode = itemBarcode70
    * itemEntityRequest.id = itemId70
    # not existing material type
    * itemEntityRequest.materialType.id = intMaterialTypeIdNonExisting
    * itemEntityRequest.status.name = 'Available'

    Given path 'inventory', 'items'
    And request itemEntityRequest
    When method POST
    Then status 422
    And match $.errors[0].message == 'Cannot set item.materialtypeid = ' + intMaterialTypeIdNonExisting + ' because it does not exist in material_type.id.'

    # If the material type is not given in the request, then we check for default material type as book in inventory, if it doesn't exist, we throw the error.
    * def materialTypeEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/item/material-type-entity-request.json')
    * materialTypeEntityRequest.name = 'book'
    Given path 'material-types'
    And request materialTypeEntityRequest
    When method GET
    Then status 200

  @CreateDCBTransaction
  Scenario: Create DCB Transaction
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def createDCBTransactionRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/create-dcb-transaction.json')
    * createDCBTransactionRequest.item.id = itemId41
    * createDCBTransactionRequest.item.barcode = itemBarcode41
    * createDCBTransactionRequest.patron.id = patronId41
    * createDCBTransactionRequest.patron.barcode = patronBarcode41
    * createDCBTransactionRequest.patron.group = patronGroupName
    * createDCBTransactionRequest.pickup.servicePointId = servicePointId21
    * createDCBTransactionRequest.pickup.servicePointName = servicePointName21
    * createDCBTransactionRequest.role = 'PICKUP'

    * def orgPath = '/transactions/' + dcbTransactionId41
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    And request createDCBTransactionRequest
    When method POST
    Then status 201
    And match $.status == 'CREATED'

  Scenario: Validation. If the userId and barcode is not exist already, new user with type DCB will be created. If it is a existing user and type is not dcb or shadow, error will be thrown.

    Given path '/users/' + patronId41
    When method GET
    Then status 200
    And match $.barcode == patronBarcode41
    And match $.type == 'dcb'

  Scenario: Validation. If it is a existing user and type is not dcb or shadow, error will be thrown.

    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def createDCBTransactionRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/create-dcb-transaction.json')
    * createDCBTransactionRequest.item.id = itemId111
    * createDCBTransactionRequest.item.barcode = itemBarcode111
    * createDCBTransactionRequest.patron.id = patronId111
    * createDCBTransactionRequest.patron.barcode = patronBarcode111
    * createDCBTransactionRequest.patron.group = patronGroupName
    * createDCBTransactionRequest.pickup.servicePointId = servicePointId21
    * createDCBTransactionRequest.pickup.servicePointName = servicePointName21
    * createDCBTransactionRequest.role = 'PICKUP'

    * def orgPath = '/transactions/' + dcbTransactionId61
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    And request createDCBTransactionRequest
    When method POST
    Then status 400
    And match $.errors[0].message == 'User with type patron is retrieved. so unable to create transaction'

  Scenario: Get User after creating dcb transaction

    Given path 'users', patronId41
    When method GET
    Then status 200
    And match $.barcode == patronBarcode41

  Scenario: Get Item status after creating dcb transaction

    Given path 'circulation-item'
    Given param query = '(barcode= ' +  itemBarcode41 + ')'
    When method GET
    Then status 200
    And match $.items[0].status.name == 'In transit'

  Scenario: Get request by barcode and item ID after creating dcb transaction

    Given path 'request-storage', 'requests'
    Given param query = '(item.barcode= ' + itemBarcode41 + ')'
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.requests[0].status == 'Open - Not yet filled'

  @GetTransactionStatusAfterCreatingDCBTransaction
  Scenario: Check Transaction status after creating dcb transaction
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/' + dcbTransactionId41 + '/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    When method GET
    Then status 200
    And match $.status == 'CREATED'
    And match $.role == 'PICKUP'


  @UpdateTransactionStatusToOpen
  Scenario: Update DCB transaction status to open.
    * def updateToOpenRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-open.json')
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/' + dcbTransactionId41 + '/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    And request updateToOpenRequest
    When method PUT
    Then status 200

  @GetTransactionStatusAfterUpdatingToOpen
  Scenario: Check Transaction status after updating it to open
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/' + dcbTransactionId41 + '/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    When method GET
    Then status 200
    And match $.status == 'OPEN'
    And match $.role == 'PICKUP'

  @GetTransactionStatusListAfterOpen
  Scenario: Get Transaction status list after Open
    * def endDate = call getCurrentUtcDate
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath
    Given path newPath
    And param apikey = key
    And param fromDate = startDate
    And param toDate = endDate
    When method GET
    Then status 200
    And match $.totalRecords == 2
    And match $.maximumPageNumber == 0
    And match response.transactions[0].id == dcbTransactionIdValidation10
    And match response.transactions[0].status == 'CANCELLED'
    And match response.transactions[1].id == dcbTransactionId41
    And match response.transactions[1].status == 'OPEN'

  @CheckIn1
  Scenario: current item check-in record and its status
    * def intCheckInDate = call read('classpath:volaris/mod-dcb/eureka-features/util/get-time-now-function.js')
    * def checkInRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/check-in/check-in-by-barcode-entity-request.json')
    * checkInRequest.itemBarcode = itemBarcode41
    * checkInRequest.servicePointId = servicePointId21

    Given path 'circulation', 'check-in-by-barcode'
    And request checkInRequest
    When method POST
    Then status 200
    * call pause 5000

  Scenario: Get Item status after manual check in

    Given path 'circulation-item'
    Given param query = '(barcode= ' +  itemBarcode41 + ')'
    When method GET
    Then status 200
    And match $.items[0].status.name == 'Awaiting pickup'

  @GetTransactionStatusAfterCheckIn1
  Scenario: Check Transaction status after manual check in
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/' + dcbTransactionId41 + '/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    When method GET
    Then status 200
    And match $.status == 'AWAITING_PICKUP'
    And match $.role == 'PICKUP'

  @GetTransactionStatusListAfterAwaitingPickup
  Scenario: Get Transaction status list after Awaiting pickup
    * def endDate = call getCurrentUtcDate
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath
    Given path newPath
    And param apikey = key
    And param fromDate = startDate
    And param toDate = endDate
    When method GET
    Then status 200
    And match $.totalRecords == 3
    And match $.maximumPageNumber == 0
    And match response.transactions[0].id == dcbTransactionIdValidation10
    And match response.transactions[0].status == 'CANCELLED'
    And match response.transactions[1].id == dcbTransactionId41
    And match response.transactions[1].status == 'OPEN'
    And match response.transactions[2].id == dcbTransactionId41
    And match response.transactions[2].status == 'AWAITING_PICKUP'

  @CheckOut
  Scenario: do check out
    * def checkOutByBarcodeId = '3a40852d-49fd-4df2-a1f9-6e2641a6e93g'
    * def checkOutByBarcodeEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/check-out/check-out-by-barcode-entity-request.json')
    * checkOutByBarcodeEntityRequest.itemBarcode = itemBarcode41
    * checkOutByBarcodeEntityRequest.userBarcode = patronBarcode41
    * checkOutByBarcodeEntityRequest.servicePointId = servicePointId21

    Given path 'circulation', 'check-out-by-barcode'
    And request checkOutByBarcodeEntityRequest
    When method POST
    Then status 201
    * call pause 5000

  Scenario: Get Item status after manual check out

    Given path 'circulation-item'
    Given param query = '(barcode= ' +  itemBarcode41 + ')'
    When method GET
    Then status 200
    And match $.items[0].status.name == 'Checked out'

  Scenario: Get request by barcode and item ID after manual check out

    Given path 'request-storage', 'requests'
    Given param query = '(item.barcode= ' + itemBarcode41 + ' )'
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.requests[0].status == 'Closed - Filled'

  Scenario: Get loan by item ID after manual check out

    Given path 'circulation-item'
    Given param query = '(barcode= ' +  itemBarcode41 + ')'
    When method GET
    Then status 200
    * def itemId = $.items[0].id

    Given path 'loan-storage', 'loans'
    Given param query = '( itemId = ' + itemId + ' )'
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.loans[0].userId == patronId41


  @GetTransactionStatusAfterCheckOut
  Scenario: Check Transaction status after manual check out
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/' + dcbTransactionId41 + '/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    When method GET
    Then status 200
    And match $.status == 'ITEM_CHECKED_OUT'
    And match $.role == 'PICKUP'

  @GetTransactionStatusListAfterCheckOut
  Scenario: Get Transaction status list after Check out
    * def endDate = call getCurrentUtcDate
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath
    Given path newPath
    And param apikey = key
    And param fromDate = startDate
    And param toDate = endDate
    And param pageSize = 3
    And param pageNumber = 1
    When method GET
    Then status 200
    And match $.totalRecords == 4
    And match $.maximumPageNumber == 1
    And match response.transactions[0].id == dcbTransactionId41
    And match response.transactions[0].status == 'ITEM_CHECKED_OUT'

  @CheckIn2
  Scenario: current item check-in record and its status
    * def intCheckInDate = call read('classpath:volaris/mod-dcb/eureka-features/util/get-time-now-function.js')
    * def checkInRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/check-in/check-in-by-barcode-entity-request.json')
    * checkInRequest.itemBarcode = itemBarcode41
    * checkInRequest.servicePointId = servicePointId21

    Given path 'circulation', 'check-in-by-barcode'
    And request checkInRequest
    When method POST
    Then status 200
    * call pause 5000

  Scenario: Get loan by item ID after manual check in

    Given path 'circulation-item'
    Given param query = '(barcode= ' +  itemBarcode41 + ')'
    When method GET
    Then status 200
    * def itemId = $.items[0].id

    Given path 'loan-storage', 'loans'
    Given param query = '( itemId = ' + itemId + ' )'
    When method GET
    Then status 200
    And match $.totalRecords == 1
    And match $.loans[0].userId == patronId41
    And match $.loans[0].status.name == 'Closed'

  Scenario: Get Item status after manual check in 2

    Given path 'circulation-item'
    Given param query = '(barcode= ' +  itemBarcode41 + ')'
    When method GET
    Then status 200
    And match $.items[0].status.name == 'In transit'

  @GetTransactionStatusAfterCheckIn2
  Scenario: Check Transaction status after manual check in
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/' + dcbTransactionId41 + '/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    When method GET
    Then status 200
    And match $.status == 'ITEM_CHECKED_IN'
    And match $.role == 'PICKUP'

  @GetTransactionStatusListAfterCheckIn
  Scenario: Get Transaction status list after Check In
    * def endDate = call getCurrentUtcDate
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath
    Given path newPath
    And param apikey = key
    And param fromDate = startDate
    And param toDate = endDate
    And param pageSize = 3
    And param pageNumber = 1
    When method GET
    Then status 200
    And match $.totalRecords == 5
    And match $.maximumPageNumber == 1
    And match response.transactions[0].id == dcbTransactionId41
    And match response.transactions[0].status == 'ITEM_CHECKED_OUT'
    And match response.transactions[1].id == dcbTransactionId41
    And match response.transactions[1].status == 'ITEM_CHECKED_IN'

  @UpdateTransactionStatusToClosed
  Scenario: Update DCB transaction status to closed.
    * def updateToClosedRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/update-dcb-transaction-to-closed.json')
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/' + dcbTransactionId41 + '/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    And request updateToClosedRequest
    When method PUT
    Then status 200

  @GetTransactionStatusAfterUpdatingToClosed
  Scenario: Check Transaction status after updating it to closed
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/' + dcbTransactionId41 + '/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath

    Given path newPath
    And param apikey = key
    When method GET
    Then status 200
    And match $.status == 'CLOSED'
    And match $.role == 'PICKUP'

  @GetTransactionStatusListAfterClosed
  Scenario: Get Transaction status list after Closed
    * def endDate = call getCurrentUtcDate
    * def baseUrlNew = proxyCall == true ? edgeUrl : baseUrl
    * url baseUrlNew
    * def orgPath = '/transactions/status'
    * def newPath = proxyCall == true ? proxyPath+orgPath : orgPath
    Given path newPath
    And param apikey = key
    And param fromDate = startDate
    And param toDate = endDate
    And param pageSize = 1
    And param pageNumber = 5
    When method GET
    Then status 200
    And match $.totalRecords == 6
    And match $.maximumPageNumber == 5
    And match response.transactions[0].id == dcbTransactionId41
    And match response.transactions[0].status == 'CLOSED'

# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\samples\check-in\check-in-by-barcode-entity-request.json

{
  "servicePointId": "#(servicePointId)",
  "checkInDate": "#(intCheckInDate)",
  "itemBarcode": "#(itemBarcode)",
  "id": "#(checkInId)"
}


# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\samples\check-in\check-in-by-non-existing-barcode-entity-request.json

{
  "servicePointId": "#(servicePointId)",
  "checkInDate": "#(intCheckInDate)",
  "itemBarcode": "#(itemNonExistingBarcode)",
  "id": "#(checkInId)"
}


# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\samples\check-out\check-out-by-barcode-entity-request.json

{
  "id": "#(checkOutByBarcodeId)",
  "itemBarcode": "12345",
  "userBarcode": "54321",
  "servicePointId": "#(servicePointId)",
  "loanDate": "2021-10-27T13:25:46.000Z"
}

# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\samples\holdings\holdings-entity-request.json

{
  "id": "#(holdingId)",
  "instanceId": "#(instanceId)",
  "permanentLocationId": "#(locationId)",
  "sourceId": "#(sourceId)"
}


# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\samples\instance\contributor-name-type-entity-request.json

{
  "id": "#(contributorNameTypeId)",
  "name": "contributor-name type name"
}


# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\samples\instance\instance-entity-request.json

{
  "id": "#(instanceId)",
  "title": "Long Way to a Small Angry Planet",
  "source":"FOLIO",
  "instanceTypeId": "#(instanceTypeId)",
  "contributors": [
    {
      "contributorNameTypeId": "#(contributorNameTypeId)",
      "name": "Chambers, Becky"
    }
  ]
}


# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\samples\instance\instance-type-entity-request.json

{
  "id": "#(instanceTypeId)",
  "name": "instance type name",
  "code":"instance type code",
  "source": "instance type source"
}


# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\samples\item\item-entity-request.json

{
  "id": "#(itemId)",
  "holdingsRecordId": "#(holdingId)",
  "materialType": {
    "id": "#(materialTypeId)",
    "name": "book"
  },
  "callNumber": "#(callNumber)",
  "permanentLoanType" : {
    "id": "#(permanentLoanTypeId)"
  },
  "status": {
    "name": "#(itemStatusName)"
  },
  "effectiveCallNumberComponents": {
    "callNumber": "#(itemCallNumber)",
    "prefix": "#(itemPrefix)",
    "suffix": "#(itemSuffix)"
  },
  "itemLevelCallNumber": "#(itemLevelCallNumber)",
  "itemLevelCallNumberPrefix": "#(callNumberPrefix)",
  "itemLevelCallNumberSuffix": "#(callNumberSuffix)"
}

# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\samples\item\material-type-entity-request.json

{
  "id": "#(materialTypeId)",
  "name": "#(materialTypeName)"
}


# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\samples\item\permanent-loan-type-entity-request.json

{
  "id": "#(permanentLoanTypeId)",
  "name": "permanent loan type name"
}


# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\samples\location\location-entity-request.json

{
  "id": "#(locationId)",
  "name": "location name",
  "code": "location code",
  "institutionId": "#(institutionId)",
  "campusId": "#(campusId)",
  "libraryId": "#(libraryId)",
  "servicePointIds": [
    "#(servicePointId)"
  ],
  "primaryServicePoint": "#(servicePointId)"
}


# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\samples\location\location-unit-campus-entity-request.json

{
  "id": "#(campusId)",
  "name": "campus name",
  "institutionId": "#(institutionId)",
  "code": "campus code"
}


# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\samples\location\location-unit-institution-entity-request.json

{
  "id": "#(institutionId)",
  "name": "institution name",
  "code": "institution code"
}


# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\samples\location\location-unit-library-entity-request.json

{
  "id": "#(libraryId)",
  "name": "library name",
  "code": "library code",
  "campusId": "#(campusId)"
}


# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\samples\patron\create-patronGroup-request.json

{
  "group": "#(patronName)",
  "desc": "For Testing",
  "expirationOffsetInDays": "60",
  "id": "#(patronId)"
}

# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\samples\policies\loan-policy-entity-request.json

{
  "id": "#(loanPolicyId)",
  "name": "Example Loan Policy",
  "description": "Can circulate item",
  "loanable": true,
  "renewable": true,
  "loansPolicy": {
    "profileId": "Rolling",
    "period": {
      "duration": 3,
      "intervalId": "Weeks"
    },
    "closedLibraryDueDateManagementId": "CURRENT_DUE_DATE_TIME"
  },
  "renewalsPolicy": {
    "renewFromId": "CURRENT_DUE_DATE",
    "unlimited": true,
    "differentPeriod": false
  },
  "requestManagement": {
    "holds": {
      "alternateRenewalLoanPeriod": {
        "duration": 3,
        "intervalId": "Weeks"
      },
      "renewItemsWithRequest": true
    },
    "recalls": {
      "alternateGracePeriod": {
        "duration": 1,
        "intervalId": "Months"
      },
      "minimumGuaranteedLoanPeriod": {
        "duration": 2,
        "intervalId": "Weeks"
      },
      "recallReturnInterval": {
        "duration": 3,
        "intervalId": "Days"
      },
      "alternateRecallReturnInterval": {
        "duration": 4,
        "intervalId": "Hours"
      }
    }
  }
}


# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\samples\policies\loan-policy-entity-with-limit-request.json

{
  "id": "#(loanPolicyId)",
  "name": "Example Loan Policy",
  "description": "Can circulate item",
  "loanable": true,
  "renewable": true,
  "loansPolicy": {
    "profileId": "Rolling",
    "period": {
      "duration": 3,
      "intervalId": "Weeks"
    },
    "closedLibraryDueDateManagementId": "CURRENT_DUE_DATE_TIME",
    "itemLimit": 1
  },
  "renewalsPolicy": {
    "renewFromId": "CURRENT_DUE_DATE",
    "unlimited": true,
    "differentPeriod": false
  },
  "requestManagement": {
    "holds": {
      "alternateRenewalLoanPeriod": {
        "duration": 3,
        "intervalId": "Weeks"
      },
      "renewItemsWithRequest": true
    },
    "recalls": {
      "alternateGracePeriod": {
        "duration": 1,
        "intervalId": "Months"
      },
      "minimumGuaranteedLoanPeriod": {
        "duration": 2,
        "intervalId": "Weeks"
      },
      "recallReturnInterval": {
        "duration": 3,
        "intervalId": "Days"
      },
      "alternateRecallReturnInterval": {
        "duration": 4,
        "intervalId": "Hours"
      }
    }
  }
}


# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\samples\policies\lost-item-fee-policy-entity-request.json

{
  "name": "Undergrad standard",
  "description": "This is description for undergrad standard",
  "itemAgedLostOverdue": {
    "duration": 12,
    "intervalId": "Months"
  },
  "patronBilledAfterAgedLost": {
    "duration": 12,
    "intervalId": "Months"
  },
  "chargeAmountItem": {
    "chargeType": "anotherCost",
    "amount": 10.00
  },
  "lostItemProcessingFee": 5.00,
  "chargeAmountItemPatron": true,
  "chargeAmountItemSystem": true,
  "lostItemChargeFeeFine": {
    "duration": 6,
    "intervalId": "Months"
  },
  "returnedLostItemProcessingFee": true,
  "replacedLostItemProcessingFee": true,
  "replacementProcessingFee": 0.00,
  "replacementAllowed": true,
  "lostItemReturned": "Charge",
  "id": "#(lostItemFeePolicyId)"
}


# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\samples\policies\overdue-fine-policy-entity-request.json

{
  "name": "Faculty standard",
  "description": "This is description for Faculty standard",
  "overdueFine": {
    "quantity": 5.0,
    "intervalId": "minute"
  },
  "countClosed": true,
  "maxOverdueFine": 50.00,
  "forgiveOverdueFine": true,
  "overdueRecallFine": {
    "quantity": 1.0,
    "intervalId": "minute"
  },
  "gracePeriodRecall": false,
  "maxOverdueRecallFine": 50.00,
  "id": "#(overdueFinePoliciesId)"
}


# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\samples\policies\patron-notice-policy-entity-request.json

{
  "id" : "#(patronPolicyId)",
  "name" : "firstPolicy",
  "description" : "description",
  "loanNotices" : [ ],
  "feeFineNotices" : [ ],
  "requestNotices" : [
    {
      "name" : "Request notice ",
      "templateId" : "2d5f138f-e088-4dff-80f6-9830f13bcde7",
      "format" : "Email",
      "realTime" : false,
      "sendOptions" : {
        "sendWhen" : "Recall request"
      }
    }
  ]
}


# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\samples\policies\request-policy-entity-request.json

{
  "id": "#(requestPolicyId)",
  "name": "Example Request Policy",
  "description" : "Description of request policy",
  "requestTypes" : "#(requestTypes)"
}


# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\samples\request\cancel-request-entity-request.json

{
  "cancellationReasonId": "#(cancellationReasonId)",
  "cancellationAdditionalInformation": "Patron Cancelled",
  "cancelledByUserId": "#(cancelledByUserId)",
  "cancelledDate": "2022-04-06T10:26:40.115Z",
  "fulfillmentPreference": "Hold Shelf",
  "instanceId": "#(instanceId)",
  "requesterId": "#(requesterId)",
  "requestDate": "2021-10-27T15:51:02Z",
  "requestLevel": "#(requestLevel)",
  "requestType": "#(requestType)",
  "holdingsRecordId": "#(holdingsRecordId)",
  "pickupServicePointId": "#(servicePointId)",
  "itemId": "#(itemId)",
  "status": "Closed - Cancelled"
}

# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\samples\request\cancellation-reason-entity-request.json

{
  "id": "#(cancellationReasonId)",
  "name": "Cancellation reason",
  "requiresAdditionalInformation": false
}

# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\samples\service-point\service-point-entity-request.json

{
  "id": "#(servicePointId)",
  "name": "service point name",
  "code":"service point code",
  "discoveryDisplayName":"service point display name",
  "pickupLocation": true,
  "holdShelfExpiryPeriod": {
    "duration": 3,
    "intervalId": "Weeks"
  },
  "staffSlips": []
}

# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\samples\transaction\create-dcb-transaction-for-borrower.json

{
  "item": {
    "id": "#(extItemId)",
    "title": "Test",
    "barcode": "#(itemBarcode)",
    "pickupLocation": "Datalogisk Institut",
    "materialType": "#(materialTypeName)",
    "lendingLibraryCode": "KU"
  },
  "patron": {
    "id": "#(extUserId)",
    "group": "#(patronName)",
    "barcode": "#(extUserBarcode)",
    "borrowingLibraryCode": "E"
  },
  "pickup": {
    "servicePointId": "afbd1042-794a-11ee-b962-0242ac120002",
    "servicePointName": "TestServicePointCode6",
    "libraryName": "TestLibraryName6",
    "libraryCode": "TestLibraryCode6"
  },
  "role": "BORROWER"
}

# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\samples\transaction\create-dcb-transaction-for-borrowing-pickup.json

{
  "item": {
    "id": "#(extItemId)",
    "title": "Test",
    "barcode": "#(itemBarcode)",
    "pickupLocation": "Datalogisk Institut",
    "materialType": "#(materialTypeName)",
    "lendingLibraryCode": "KU"
  },
  "patron": {
    "id": "#(extUserId)",
    "group": "#(patronName)",
    "barcode": "#(extUserBarcode)",
    "borrowingLibraryCode": "E"
  },
  "pickup": {
    "servicePointId": "afbd1042-794a-11ee-b962-0242ac120002",
    "servicePointName": "TestServicePointCode6",
    "libraryName": "TestLibraryName6",
    "libraryCode": "TestLibraryCode6"
  },
  "role": "BORROWING-PICKUP"
}

# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\samples\transaction\create-dcb-transaction-for-pickup.json

{
  "item": {
    "id": "#(extItemId)",
    "title": "Test",
    "barcode": "#(itemBarcode)",
    "pickupLocation": "Datalogisk Institut",
    "materialType": "#(materialTypeName)",
    "lendingLibraryCode": "KU"
  },
  "patron": {
    "id": "#(userId)",
    "group": "#(patronName)",
    "barcode": "#(barcode)",
    "borrowingLibraryCode": "E"
  },
  "pickup": {
    "servicePointId": "afbd1042-794a-11ee-b962-0242ac120002",
    "servicePointName": "TestServicePointCode6",
    "libraryName": "TestLibraryName6",
    "libraryCode": "TestLibraryCode6"
  },
  "role": "PICKUP"
}

# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\samples\transaction\create-dcb-transaction.json

{
  "item": {
    "id": "#(extItemId)",
    "title": "Test",
    "barcode": "#(itemBarcode)",
    "pickupLocation": "Datalogisk Institut",
    "materialType": "namebook",
    "lendingLibraryCode": "KU"
  },
  "patron": {
    "id": "#(patronId)",
    "group": "#(patronName)",
    "barcode": "#(patronBarcode)",
    "borrowingLibraryCode": "E"
  },
  "pickup": {
    "servicePointId": "afbd1042-794a-11ee-b962-0242ac120003",
    "servicePointName": "TestServicePointCode6",
    "libraryCode": "TestLibraryCode6"
  },
  "role": "LENDER"
}

# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\samples\transaction\update-dcb-transaction-status.json

{
  "status": "OPEN"
}

# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\samples\transaction\update-dcb-transaction-to-awaiting-pickup.json

{
  "status": "AWAITING_PICKUP"
}

# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\samples\transaction\update-dcb-transaction-to-cancel.json

{
  "status": "CANCELLED"
}

# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\samples\transaction\update-dcb-transaction-to-close.json

{
  "status": "CLOSED"
}

# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\samples\transaction\update-dcb-transaction-to-closed.json

{
  "status" : "CLOSED"
}

# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\samples\transaction\update-dcb-transaction-to-item-check-in.json

{
  "status": "ITEM_CHECKED_IN"
}

# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\samples\transaction\update-dcb-transaction-to-item-check-out.json

{
  "status": "ITEM_CHECKED_OUT"
}

# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\samples\transaction\update-dcb-transaction-to-open.json

{
  "status": "OPEN"
}

# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\samples\user\group-entity-request.json

{
  "id": "#(patronGroupId)",
  "group": "#(patronGroupName)"
}


# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\samples\user\user-entity-request.json

{
  "active": true,
  "departments": [],
  "id": "#(patronId)",
  "patronGroup": "#(patronGroupId)",
  "barcode": "#(patronBarcode)",
  "personal": {
    "email": "testuser@gmail.com",
    "firstName": "first name ",
    "lastName": "last name",
    "preferredContactTypeId": "002"
  }
}


# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\update-transaction-status.feature

Feature: Testing Update transaction status

  Background:
    * url baseUrl

    * callonce login testUser
    * def okapitokenUser = okapitoken
    * def headersUser = { 'Content-Type': 'application/json', 'x-okapi-token': '#(okapitokenUser)', 'x-okapi-tenant': '#(testTenant)', 'Accept': 'application/json'  }
    * configure headers = headersUser

  Scenario: Update transaction status to AWAITING_PICKUP
    * def dcbTransactionId = '1234568'

    Given path '/transactions/' + dcbTransactionId
    And request
    """
    {
      "status": "AWAITING_PICKUP"
    }
    """
    When method PUT
    Then status 200


# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\util\get-time-now-function.js

function () {
  var SimpleDateFormat = Java.type('java.text.SimpleDateFormat');
  var sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'");
  var date = new java.util.Date();
  return sdf.format(date);
}


# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\util\initData.feature

Feature: init data for mod-dcb

  Background:
    * url baseUrl
    * callonce login testUser
    * configure headers = { 'Content-Type': 'application/json', 'x-okapi-token': '#(okapitoken)', 'x-okapi-tenant': '#(testTenant)', 'Accept': 'application/json, text/plain' }

      # load global variables
    * callonce variables

  @PostInstance
  Scenario: create instance

    * def instanceTypeEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/instance/instance-type-entity-request.json')
    * instanceTypeEntityRequest.id = karate.get('extInstanceTypeId', intInstanceTypeId)
    * instanceTypeEntityRequest.name = instanceTypeEntityRequest.name + ' ' + random_string()
    * instanceTypeEntityRequest.code = instanceTypeEntityRequest.code + ' ' + random_string()
    * instanceTypeEntityRequest.source = instanceTypeEntityRequest.source + ' ' + random_string()

    Given path 'instance-types'
    And request instanceTypeEntityRequest
    When method POST
    Then status 201

    * def contributorNameTypeEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/instance/contributor-name-type-entity-request.json')
    * contributorNameTypeEntityRequest.name = contributorNameTypeEntityRequest.name + ' ' + random_string()
    Given path 'contributor-name-types'
    And request contributorNameTypeEntityRequest
    When method POST
    Then status 201

    * def instanceEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/instance/instance-entity-request.json')
    * instanceEntityRequest.instanceTypeId = karate.get('extInstanceTypeId', intInstanceTypeId)
    * instanceEntityRequest.id = karate.get('extInstanceId', instanceId)
    Given path 'inventory', 'instances'
    And request instanceEntityRequest
    When method POST
    Then status 201

# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\util\initData2.feature

Feature: init data for mod-dcb

  Background:
    * url baseUrl
    * callonce login testUser
    * configure headers = { 'Content-Type': 'application/json', 'x-okapi-token': '#(okapitoken)', 'x-okapi-tenant': '#(testTenant)', 'Accept': 'application/json, text/plain' }

  @PostLocation
  Scenario: create location
    * def intInstitutionId = '2738c8aa-77b1-11ee-b962-0242ac120002'
    * def intCampusId = '2d475ac2-77b1-11ee-b962-0242ac120002'
    * def intLibraryId = '338b7f8a-77b1-11ee-b962-0242ac120002'

    * def locationUnitInstitutionEntityRequest = read('samples/location/location-unit-institution-entity-request.json')
    * locationUnitInstitutionEntityRequest.id = karate.get('extInstitutionId', intInstitutionId)
    * locationUnitInstitutionEntityRequest.name = locationUnitInstitutionEntityRequest.name + ' ' + random_string()
    Given path 'location-units', 'institutions'
    And request locationUnitInstitutionEntityRequest
    When method POST
    Then status 201

    * def locationUnitCampusEntityRequest = read('samples/location/location-unit-campus-entity-request.json')
    * locationUnitCampusEntityRequest.institutionId = karate.get('extInstitutionId', intInstitutionId)
    * locationUnitCampusEntityRequest.id = karate.get('extCampusId', intCampusId)
    * locationUnitCampusEntityRequest.name = locationUnitCampusEntityRequest.name + ' ' + random_string()
    * locationUnitCampusEntityRequest.code = locationUnitCampusEntityRequest.code + ' ' + random_string()
    Given path 'location-units', 'campuses'
    And request locationUnitCampusEntityRequest
    When method POST
    Then status 201

    * def locationUnitLibraryEntityRequest = read('samples/location/location-unit-library-entity-request.json')
    * locationUnitLibraryEntityRequest.id = karate.get('extLibraryId', intLibraryId)
    * locationUnitLibraryEntityRequest.campusId = karate.get('extCampusId', intCampusId)
    * locationUnitLibraryEntityRequest.name = locationUnitLibraryEntityRequest.name + ' ' + random_string()
    * locationUnitLibraryEntityRequest.code = locationUnitLibraryEntityRequest.code + ' ' + random_string()
    Given path 'location-units', 'libraries'
    And request locationUnitLibraryEntityRequest
    When method POST
    Then status 201

    * def locationEntityRequest = read('samples/location/location-entity-request.json')
    * locationEntityRequest.id = karate.get('extLocationId', locationId)
    * locationEntityRequest.institutionId = karate.get('extInstitutionId', intInstitutionId)
    * locationEntityRequest.campusId = karate.get('extCampusId', intCampusId)
    * locationEntityRequest.libraryId = karate.get('extLibraryId', intLibraryId)
    * locationEntityRequest.primaryServicePoint = karate.get('extServicePointId', servicePointId)
    * locationEntityRequest.servicePointIds = [karate.get('extServicePointId', servicePointId)]
    * locationEntityRequest.name = locationEntityRequest.name + ' ' + random_string()
    * locationEntityRequest.code = locationEntityRequest.code + ' ' + random_string()
    Given path 'locations'
    And request locationEntityRequest
    When method POST
    Then status 201

  @PostServicePoint
  Scenario: create service point
    * def servicePointEntityRequest = read('samples/service-point/service-point-entity-request.json')
    * servicePointEntityRequest.id = karate.get('extServicePointId', servicePointId)
    * servicePointEntityRequest.name = servicePointEntityRequest.name + ' ' + random_string()
    * servicePointEntityRequest.code = servicePointEntityRequest.code + ' ' + random_string()
    Given path 'service-points'
    And request servicePointEntityRequest
    When method POST
    Then status 201

  @PostInstance
  Scenario: create instance
    * def intInstanceTypeId = '0f97f0fc-77b3-11ee-b962-0242ac120002'
    * def contributorNameTypeId = '176915ea-77b3-11ee-b962-0242ac120002'
    * def instanceTypeEntityRequest = read('samples/instance/instance-type-entity-request.json')
    * instanceTypeEntityRequest.id = karate.get('extInstanceTypeId', intInstanceTypeId)
    * instanceTypeEntityRequest.name = instanceTypeEntityRequest.name + ' ' + random_string()
    * instanceTypeEntityRequest.code = instanceTypeEntityRequest.code + ' ' + random_string()
    * instanceTypeEntityRequest.source = instanceTypeEntityRequest.source + ' ' + random_string()

    Given path 'instance-types'
    And request instanceTypeEntityRequest
    When method POST
    Then status 201

    * def contributorNameTypeEntityRequest = read('samples/instance/contributor-name-type-entity-request.json')
    * contributorNameTypeEntityRequest.name = contributorNameTypeEntityRequest.name + ' ' + random_string()
    Given path 'contributor-name-types'
    And request contributorNameTypeEntityRequest
    When method POST
    Then status 201

    * def instanceEntityRequest = read('samples/instance/instance-entity-request.json')
    * instanceEntityRequest.instanceTypeId = karate.get('extInstanceTypeId', intInstanceTypeId)
    * instanceEntityRequest.id = karate.get('extInstanceId', instanceId)
    Given path 'inventory', 'instances'
    And request instanceEntityRequest
    When method POST
    Then status 201

  @PostGroup
  Scenario: create group
    * def intUserGroupId = '5edd4dce-77b3-11ee-b962-0242ac120002'
    * def groupEntityRequest = read('samples/user/group-entity-request.json')
    * groupEntityRequest.id = karate.get('extUserGroupId', intUserGroupId)
    * groupEntityRequest.group = groupEntityRequest.group + ' ' + random_string()
    Given path 'groups'
    And request groupEntityRequest
    When method POST
    Then status 201

  @PostUser
  Scenario: create user
    * def intUserId = '8b83f6b6-77b3-11ee-b962-0242ac120002'
    * def userEntityRequest = read('samples/user/user-entity-request.json')
    * userEntityRequest.barcode = extUserBarcode
    * userEntityRequest.patronGroup = karate.get('extGroupId', groupId)
    * userEntityRequest.id = karate.get('extUserId', intUserId)
    Given path 'users'
    And request userEntityRequest
    When method POST
    Then status 201

  @CheckInItem
  Scenario: check in item by barcode
    * def checkInId = '4257262e-77b4-11ee-b962-0242ac120002'
    * def intCheckInDate = call read('classpath:vega/mod-circulation/eureka-features/util/get-time-now-function.js')

    * def checkInRequest = read('classpath:vega/mod-circulation/eureka-features/samples/check-in-by-barcode-entity-request.json')
    * checkInRequest.servicePointId = karate.get('extServicePointId', servicePointId)
    * checkInRequest.checkInDate = karate.get('extCheckInDate', intCheckInDate)
    Given path 'circulation', 'check-in-by-barcode'
    And request checkInRequest
    When method POST
    Then status 200
    And match $.item.barcode == itemBarcode
    And match $.item.status.name == 'In transit'
    And call pause 5000

  @PostItem
  Scenario: create item
    * def permanentLoanTypeId = '311a85f6-77b7-11ee-b962-0242ac120002'
    * def intItemId = '3c497cc0-77b7-11ee-b962-0242ac120002'
    * def intStatusName = 'Available'

    * def permanentLoanTypeEntityRequest = read('samples/item/permanent-loan-type-entity-request.json')
    * permanentLoanTypeEntityRequest.name = permanentLoanTypeEntityRequest.name + ' ' + random_string()
    Given path 'loan-types'
    And request permanentLoanTypeEntityRequest
    When method POST
    Then status 201

    * def itemEntityRequest = read('samples/item/item-entity-request.json')
    * itemEntityRequest.barcode = extItemBarcode
    * itemEntityRequest.id = karate.get('extItemId', intItemId)
    * itemEntityRequest.holdingsRecordId = karate.get('extHoldingsRecordId', holdingId)
    * itemEntityRequest.materialType.id = karate.get('extMaterialTypeId', intMaterialTypeId)
    * itemEntityRequest.status.name = karate.get('extStatusName', intStatusName)
    Given path 'inventory', 'items'
    And request itemEntityRequest
    When method POST
    Then status 201

  @PostCheckOut
  Scenario: do check out
    * def intLoanDate = '2021-10-27T13:25:46.000Z'
    * def checkOutByBarcodeEntityRequest = read('samples/check-out/check-out-by-barcode-entity-request.json')
    * checkOutByBarcodeEntityRequest.userBarcode = extCheckOutUserBarcode
    * checkOutByBarcodeEntityRequest.itemBarcode = extCheckOutItemBarcode
    * checkOutByBarcodeEntityRequest.servicePointId = karate.get('extServicePointId', servicePointId)
    * checkOutByBarcodeEntityRequest.loanDate = karate.get('extLoanDate', intLoanDate)
    Given path 'circulation', 'check-out-by-barcode'
    And request checkOutByBarcodeEntityRequest
    When method POST
    Then status 201



# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\util\initData3.feature

Feature: init data for mod-dcb

  Background:
    * url baseUrl
    * callonce login testUser
    * configure headers = { 'Content-Type': 'application/json', 'x-okapi-token': '#(okapitoken)', 'x-okapi-tenant': '#(testTenant)', 'Accept': 'application/json, text/plain' }

  @PostInstance
  Scenario: create instance

    * def instanceTypeEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/instance/instance-type-entity-request.json')
    * instanceTypeEntityRequest.id = karate.get('extInstanceTypeId', intInstanceTypeId)
    * instanceTypeEntityRequest.name = instanceTypeEntityRequest.name + ' ' + random_string()
    * instanceTypeEntityRequest.code = instanceTypeEntityRequest.code + ' ' + random_string()
    * instanceTypeEntityRequest.source = instanceTypeEntityRequest.source + ' ' + random_string()

    Given path 'instance-types'
    And request instanceTypeEntityRequest
    When method POST
    Then status 201

    * def contributorNameTypeEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/instance/contributor-name-type-entity-request.json')
    * contributorNameTypeEntityRequest.name = contributorNameTypeEntityRequest.name + ' ' + random_string()
    Given path 'contributor-name-types'
    And request contributorNameTypeEntityRequest
    When method POST
    Then status 201

    * def instanceEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/instance/instance-entity-request.json')
    * instanceEntityRequest.instanceTypeId = karate.get('extInstanceTypeId', intInstanceTypeId)
    * instanceEntityRequest.id = karate.get('extInstanceId', instanceId)
    Given path 'inventory', 'instances'
    And request instanceEntityRequest
    When method POST
    Then status 201

  @PostHoldings
  Scenario: create holdings
    * def holdingsEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/holdings/holdings-entity-request.json')
    * holdingsEntityRequest.id = karate.get('extHoldingsRecordId', holdingId)
    * holdingsEntityRequest.instanceId = karate.get('extInstanceId', instanceId)
    * holdingsEntityRequest.permanentLocationId = karate.get('extLocationId', locationId)
    Given path 'holdings-storage', 'holdings'
    And request holdingsEntityRequest
    When method POST
    Then status 201

  @PostItem
  Scenario: create item
    * def permanentLoanTypeEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/item/permanent-loan-type-entity-request.json')
    * permanentLoanTypeEntityRequest.name = permanentLoanTypeEntityRequest.name + ' ' + random_string()
    Given path 'loan-types'
    And request permanentLoanTypeEntityRequest
    When method POST
    Then status 201

    * def itemEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/item/item-entity-request.json')
    * itemEntityRequest.barcode = extItemBarcode
    * itemEntityRequest.id = karate.get('extItemId', intItemId)
    * itemEntityRequest.holdingsRecordId = karate.get('extHoldingsRecordId', holdingId)
    * itemEntityRequest.materialType.id = karate.get('extMaterialTypeId', intMaterialTypeId)
    * itemEntityRequest.status.name = karate.get('extStatusName', intStatusName)
    Given path 'inventory', 'items'
    And request itemEntityRequest
    When method POST
    Then status 201

  @PostGroup
  Scenario: create group
    * def intUserGroupId = '5edd4dce-77b3-11ee-b962-0242ac120002'
    * def groupEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/user/group-entity-request.json')
    * groupEntityRequest.id = karate.get('extUserGroupId', intUserGroupId)
    * groupEntityRequest.group = groupEntityRequest.group + ' ' + random_string()
    Given path 'groups'
    And request groupEntityRequest
    When method POST
    Then status 201

  @PostUser
  Scenario: create user
    * def intUserId = '8b83f6b6-77b3-11ee-b962-0242ac120002'
    * def userEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/user/user-entity-request.json')
    * userEntityRequest.barcode = extUserBarcode
    * userEntityRequest.patronGroup = karate.get('extGroupId', groupId)
    * userEntityRequest.id = karate.get('extUserId', intUserId)
    Given path 'users'
    And request userEntityRequest
    When method POST
    Then status 201



# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-features\util\random_numbers.feature

@ignore
Feature:

Scenario:
* def random_numbers = function() { return Math.floor(Math.random() * 1000000) }


# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-global\variables.feature

Feature: global variables

  @GlobalVariables
  Scenario: use global variables
    * def intInstanceTypeId = '0f97f0fc-77b3-11ee-b962-0242ac120002'
    * def contributorNameTypeId = '176915ea-77b3-11ee-b962-0242ac120002'

    * def permanentLoanTypeId = '311a85f6-77b7-11ee-b962-0242ac120002'

    * def intItemId = '3c497cc0-77b7-11ee-b962-0242ac120002'
    * def intItemId1 = '87fb26fa-91cc-4a94-ba2f-8903ff792460'
    * def intItemId2 = 'e68b3153-11a8-47ee-ba80-75b1c0d332c1'
    * def intItemId3 = 'eaf59922-b3fc-4ab5-8c2d-6a884247e9b3'
    * def intItemId4 = 'a9576acb-83ee-4819-bee0-d27f07863f23'
    * def intItemId5 = 'b9576adb-83ee-4819-bee0-d27f07863f23'
    * def intItemId6 = 'b9576aeb-83ee-4819-bee0-d27f07863f23'
    * def intStatusName = 'Available'

    * def dcbTransactionId = '123456891'
    * def dcbTransactionIdNonExisting = '123'
    * def itemBarcode = 'newdcb12'
    * def itemBarcode1 = 'newdcb123'
    * def itemBarcode2 = 'newdcb1234'
    * def itemBarcode3 = 'newdcb12345'
    * def itemBarcode4 = 'newdcb123456'
    * def itemBarcode5 = 'newdcb1234567'
    * def itemBarcode6 = 'newdcb1234568'
    * def itemNonExistingBarcode = 'newdcb1111'
    * def patronId = 'ad2164c7-ba3d-1bc2-a12c-e35ceccbfaf2'
    * def patronName = 'patronName1'
    * def patronBarcode = '1111111'
    * def instanceId = 'ea614654-73d8-11ee-b962-0242ac120002'

    * def contributorNameTypeId = 'f2cedf06-73d1-11ee-b962-0242ac120002'
    * def institutionId = '8e30bb06-76ff-11ee-b962-0242ac120002'
    * def locationId = '0afceb26-77d9-11ee-b962-0242ac120002'
    * def campusId = 'ae12d634-76ff-11ee-b962-0242ac120002'
    * def libraryId = 'b55e9040-76ff-11ee-b962-0242ac120002'
    * def locationId = 'd8b25bb2-76ff-11ee-b962-0242ac120002'
    * def holdingId = '70cf22e6-779f-11ee-b962-0242ac120002'
    * def checkInId = 'ea1235da-779a-11ee-b962-0242ac120002'
    * def extRequestType = 'Page'
    * def extRequestId = 'ef1235da-779a-11ee-b962-0242ac120002'

    * def extItemId = 'c7a2f4de-77af-11ee-b962-0242ac120003'
    * def extItemId1 = 'bf12d634-76ff-11ee-b962-0242ac120004'
    * def extItemId2 = 'd8b25bb2-76ff-11ee-b962-0242ac120005'
    * def extItemId3 = 'c7a2f4de-77af-11ee-b962-0242ac120006'
    * def extItemId4 = '70cf22e6-779f-11ee-b962-0242ac120007'
    * def extItemId5 = '70cf22e6-779f-11ee-b962-0242ac120008'
    * def extItemId6 = '70cf22f6-779f-11ee-b962-0242ac120008'
    * def extUserBarcode = 'FAT-993IBC'
    * def extUserBarcode1 = 'FAT-993IBD'
    * def extItemBarcode = 'FAT-993IBC'
    * def extUserId = 'a9b73276-77b6-11ee-b962-0242ac120002'
    * def extUserId1 = 'a9b73277-77b6-11ee-b962-0242ac120002'

    * def intInstitutionId = '52914c6c-77d8-11ee-b962-0242ac120002'
    * def intCampusId = '592e58da-77d8-11ee-b962-0242ac120002'
    * def intLibraryId = '60bda6c8-77d8-11ee-b962-0242ac120002'
    * def cancellationReasonId = 'ea614654-73d8-11ee-b962-0242ac120003'

    * def extInstanceTypeId = 'ab164870-77af-11ee-b962-0242ac120002'
    * def extInstitutionId = 'b1ad12f4-77af-11ee-b962-0242ac120002'
    * def extCampusId = 'b812fdf2-77af-11ee-b962-0242ac120002'
    * def extLibraryId = 'bf61fea0-77af-11ee-b962-0242ac120002'
    * def extItemBarcode = 'FAT-unknownIBC'

    * def servicePointId = 'afbd1042-794a-11ee-b962-0242ac120002'

    * def intMaterialTypeId = 'daf1aaea-794d-11ee-b962-0242ac150002'
#    * def materialTypeName = 'e182c8a8-794d-11ee-b962-0242ac120002'
    * def intUserGroupId = '5edd4dce-77b3-11ee-b962-0242ac120002'
    * def checkInId = '4257262e-77b4-11ee-b962-0242ac120002'
    * def intLoanDate = '2021-10-27T13:25:46.000Z'

    * def materialTypeId = 'daf1aaea-794d-11ee-b962-0242ac120002'
    * def materialTypeName = 'namebook'
    * def itemStatusName = 'Available'
    * def patronGroupId = '5edd4dce-77b3-11ee-b962-0242ac120003'
    * def patronGroupName = 'staff gyu708765'
    * def servicePointId = 'afbd1042-794a-11ee-b962-0242ac120002'
    * def servicePointName = 'test service point'
    * def servicePointCode = 'test'

    * def servicePointId11 = '3a40852d-49fd-4df2-a1f9-6e2641a6e71f'
    * def servicePointId21 = '5d2625ef-81eb-4e61-a8a9-87c94ba3774d'

    * def servicePointName11 = 'Circ Desky 10'
    * def servicePointName21 = 'Circ Desky 20'

    * def servicePointCode11 = 'cdy10'
    * def servicePointCode21 = 'cdy20'

    * def patronId11 = 'e58ca3a7-7674-44e5-8a1c-cdb22d0f87ec'
    * def patronId21 = 'e58ca3a7-7674-44e5-8a1c-cdb22d0f87ce'
    * def patronId31 = 'ee6542c3-f98e-414a-94e4-caad908aebdf'
    * def patronId41 = 'ee6542c3-f98e-414a-94e4-caad908aeb00'

    * def patronBarcode11 = 'testuser123'
    * def patronBarcode21 = 'testuser12345'
    * def patronBarcode31 = 'testuser987'
    * def patronBarcode41 = 'testuser98765'

    * def dcbTransactionId11 = '1234'
    * def dcbTransactionId21 = '12345'
    * def dcbTransactionId31 = '987'
    * def dcbTransactionId41 = '98765'

    * def itemId11 = 'e58ca7a7-7674-44e5-8a1c-cdb22d0f87ce'
    * def itemId21 = '91aa52cb-29d2-41c1-99a2-fb9b293956dc'
    * def itemId31 = '565a17a1-e258-4973-bab6-da176010ea3c'
    * def itemId32 = 'ca90e0fc-68f5-4547-ab3e-4d5076e18818'
    * def itemId41 = '3c497cc0-77b7-11ee-b962-0242ac120003'
    * def itemId51 = '3c497cc0-77b7-11ee-b962-0242ac120004'
    * def itemId61 = '3c497cc0-77b7-11ee-b962-0242ac120005'
    * def itemId71 = '3c497cc0-77b7-11ee-b962-0242ac120006'

    * def itemBarcode11 = '18'
    * def itemBarcode21 = '19'
    * def itemBarcode31 = '20'
    * def itemBarcode32 = '32'
    * def itemBarcode41 = '21'
    * def itemBarcode51 = '22'
    * def itemBarcode61 = '23'
    * def itemBarcode71 = '24'

    * def itemNonExistingBarcode = 'newdcb11020'
    * def itemId71 = '1cbcdb7e-edcd-4874-af0b-2df1c5076737'
    * def itemBarcode311 = '3111'
    * def patronId51 = 'd0d52946-c5da-40a8-acc8-f05805135b65'
    * def patronBarcode51 = 'testuser123051'
    * def dcbTransactionId411 = '9041187'
    * def intMaterialTypeIdNonExisting = '0f656d87-b6bc-407b-b483-8066dfe89d04'
    * def itemBarcode7itemId5 = '7724'
    * def itemId5 = '63a38cea-1aa5-4a7a-87d4-8b44807ca030'
    * def itemId30 = '5e70dcc0-7ec2-42c7-b44c-9dc5d18e1961'
    * def itemBarcode30 = '30201'
    * def dcbTransactionIdValidation7 = '744'
    * def dcbTransactionIdValidation6 = '644'
    * def itemId111 = '59c97459-512d-4cc1-9aaf-8af78f3a3c17'
    * def itemId112 = '87f33284-8e71-4c75-9bc9-fcdcfa516544'
    * def itemBarcode70 = '7070'
    * def itemId60 = 'fd510fa8-b2bf-4134-b6ac-71ecd8accfc6'
    * def intMaterialTypeId3 = '175922a9-d770-46a0-9758-966d8bfc4e5c'
    * def itemId80 = '2c879e1e-6e19-4555-8824-783a02c2f407'
    * def itemId110 = '44a0b870-4096-41d6-ab88-7e9fdedf8aba'
    * def patronIdNonExisting = '8ca3438a-6d91-4341-8a39-f66d318f814d'
    * def itemIdNotExisting = '5d6cfcbe-7fc2-4945-b082-1eb149b973aa'
    * def itemId311 = '34e16895-d876-42ba-b962-422c13f27428'
    * def itemBarcode7 = '7714'
    * def patronId1 = '74a0e2a0-5a09-44a0-ac6f-471af1fe8f48'
    * def utilsPath = 'classpath:volaris/mod-dcb/reusable/pre-requisites.feature'
    * def itemId20 = '155f1705-3628-4769-9a8d-bc58a7b52932'
    * def itemBarcode50 = '5050'
    * def itemId40 = 'e6208f36-adc5-419e-82f0-3a02d28ea809'
    * def intMaterialTypeId1 = '2b086e49-e5eb-46e6-8907-13a53e41c67a'
    * def itemId20 = '37f4a7a3-5a94-4148-8fa7-42fe6cfea8c2'
    * def itemBarcode111 = '110110000'
    * def itemBarcode112 = '111000112'
    * def itemId70 = '490fcf53-542b-4ad2-ae83-f1c825ab6fa3'
    * def itemBarcode60 = '6060'
    * def intMaterialTypeName3 = '6ae81a27-6138-483c-8ed4-266a74eec312'
    * def itemBarcode80 = '80808'
    * def patronNameNonExisting = 'patronNameNonExisting'
    * def dcbTransactionId511 = '5110'
    * def itemBarcode110 = '11010'
    * def intMaterialTypeId2 = 'e61fd043-641b-4f2a-b4ab-8dbc1ab28679'
    * def patronBarcode1 = '111011'
    * def itemBarcode20 = '20200'
    * def itemBarcode40 = '4044'
    * def itemId50 = 'b1210866-50e7-44b1-bd4d-2b4e31804c5e'
    * def intMaterialTypeName1 = 'Name1'
    * def itemBarcodeAlreadyExists3 = '30300'
    * def patronId3 = '30152d24-af64-4c6c-91f4-0f81c88afcc3'
    * def patronId111 = '6fb2fad9-cbb4-441e-8b95-31535a6005bd'
    * def servicePointId1 = 'b929f6fe-720e-4c0b-88f8-2e36997962b1'
    * def dcbTransactionId611 = '611'
    * def patronId110 = 'a46a9e8e-da5c-4c86-893f-306da18dfe4f'
    * def intMaterialTypeName2 = 'name2'
    * def patronBarcodeNonExisting = 'patronBarcodeNonExisting'
    * def patronId2 = 'dde93db3-23bb-48b5-be44-cafec93cbcd8'
    * def dcbTransactionId311 = '3111'
    * def patronBarcode3 = '322'
    * def patronBarcode111 = '111'
    * def itemId7 = '44d8127c-c372-4112-ac79-d45e0e762ae1'
    * def servicePointName1 = 'servicePointName1'
    * def patronBarcode110 = '1101111'
    * def itemBarcodeAlreadyExists = '222'
    * def patronBarcode2 = '2222'
    * def dcbTransactionIdValidation11 = '1101'
    * def dcbTransactionId61 = '61111'
    * def dcbTransactionIdValidation10 = '1010'
    * def dcbTransactionIdValidation12 = '1212'
    * def dcbTransactionIdValidation20 = '202'
    * def dcbTransactionId51 = '51'
    * def dcbTransactionIdValidation8 = '88'
    * def dcbTransactionIdValidation9 = '99'
    * def dcbTransactionIdValidation1 = '11'
    * def itemId8 = 'cce9b856-77db-48c0-b6b5-7383b91d9119'
    * def dcbTransactionIdValidation2 = '202'
    * def itemBarcodeAlreadyExists2 = '2022'
    * def itemId6 = '14cddb28-f1c5-48ea-a349-5965c0aeb3dc'
    * def key = ''

# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-reusable\create-dcb-transaction-for-borrower.feature

Feature: Testing Borrowing-Pickup Cancellation Flow

  Background:
    * url baseUrl

    * callonce login testAdmin
    * def okapitokenUser = okapitoken
    * def headersUser = { 'Content-Type': 'application/json', 'x-okapi-token': '#(okapitokenUser)', 'x-okapi-tenant': '#(testTenant)', 'Accept': 'application/json, text/plain'  }
    * configure headers = headersUser

      # load global variables
    * callonce variables

  Scenario: Create transaction
    * def transaction = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/create-dcb-transaction-for-borrower.json')
    Given path 'transactions' , transactionId
    And request transaction
    When method POST
    Then status 201





# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-reusable\create-dcb-transaction-for-borrowing-pickup.feature

Feature: Testing Borrowing-Pickup Cancellation Flow

  Background:
    * url baseUrl

    * callonce login testAdmin
    * def okapitokenUser = okapitoken
    * def headersUser = { 'Content-Type': 'application/json', 'x-okapi-token': '#(okapitokenUser)', 'x-okapi-tenant': '#(testTenant)', 'Accept': 'application/json, text/plain'  }
    * configure headers = headersUser

      # load global variables
    * callonce variables

  Scenario: Create transaction
    * def transaction = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/create-dcb-transaction-for-borrowing-pickup.json')
    Given path 'transactions' , transactionId
    And request transaction
    When method POST
    Then status 201





# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-reusable\create-dcb-transaction-for-pickup.feature

Feature: Testing Borrowing-Pickup Cancellation Flow

  Background:
    * url baseUrl

    * callonce login testAdmin
    * def okapitokenUser = okapitoken
    * def headersUser = { 'Content-Type': 'application/json', 'x-okapi-token': '#(okapitokenUser)', 'x-okapi-tenant': '#(testTenant)', 'Accept': 'application/json, text/plain'  }
    * configure headers = headersUser

      # load global variables
    * callonce variables

  Scenario: Create transaction
    * def transaction = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/create-dcb-transaction-for-pickup.json')
    Given path 'transactions' , transactionId
    And request transaction
    When method POST
    Then status 201





# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-reusable\create-dcb-transaction.feature

Feature: Testing Lending Flow

  Background:
    * url baseUrl

    * callonce login testAdmin
    * def okapitokenUser = okapitoken
    * def headersUser = { 'Content-Type': 'application/json', 'x-okapi-token': '#(okapitokenUser)', 'x-okapi-tenant': '#(testTenant)', 'Accept': 'application/json, text/plain'  }
    * configure headers = headersUser

      # load global variables
    * callonce variables

  Scenario: Create
    * def transaction = read('classpath:volaris/mod-dcb/eureka-features/samples/transaction/create-dcb-transaction.json')

    Given path 'transactions' , transactionId
    And request transaction
    When method POST
    Then status 201





# C:\Projects\EPAM\FOLIO\mod-dcb\src\main\resources\volaris\mod-dcb\eureka-reusable\pre-requisites.feature

Feature: Testing Lending Flow

  Background:
    * url baseUrl
    * def proxyCall = karate.get('proxyCall', false)
    * def user = proxyCall == true ? testUser : testAdmin
    * print 'user  is', user
    * callonce login user
    * def okapitokenUser = okapitoken
    * def headersUser = { 'Content-Type': 'application/json', 'x-okapi-token': '#(okapitokenUser)', 'x-okapi-tenant': '#(testTenant)', 'Accept': 'application/json, text/plain'  }
    * configure headers = headersUser

      # load global variables
    * callonce variables

  @PostInstance
  Scenario: Create Instance
    * def instanceTypeEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/instance/instance-type-entity-request.json')
    * instanceTypeEntityRequest.id = karate.get('extInstanceTypeId', intInstanceTypeId)
    * instanceTypeEntityRequest.name = instanceTypeEntityRequest.name + ' ' + random_string()
    * instanceTypeEntityRequest.code = instanceTypeEntityRequest.code + ' ' + random_string()
    * instanceTypeEntityRequest.source = instanceTypeEntityRequest.source + ' ' + random_string()

    Given path 'instance-types'
    And request instanceTypeEntityRequest
    When method POST
    Then status 201

    * def contributorNameTypeEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/instance/contributor-name-type-entity-request.json')
    * contributorNameTypeEntityRequest.name = contributorNameTypeEntityRequest.name + ' ' + random_string()
    Given path 'contributor-name-types'
    And request contributorNameTypeEntityRequest
    When method POST
    Then status 201

    * def instanceEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/instance/instance-entity-request.json')
    * instanceEntityRequest.instanceTypeId = karate.get('extInstanceTypeId', intInstanceTypeId)
    * instanceEntityRequest.id = karate.get('extInstanceId', instanceId)
    Given path 'inventory', 'instances'
    And request instanceEntityRequest
    When method POST
    Then status 201

  @PostServicePoint
  Scenario: create service point
    * def servicePointEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/service-point/service-point-entity-request.json')
#    * servicePointEntityRequest.id = karate.get('extServicePointId', servicePointId)
    * servicePointEntityRequest.name = servicePointEntityRequest.name + ' ' + random_string()
    * servicePointEntityRequest.code = servicePointEntityRequest.code + ' ' + random_string()
    Given path 'service-points'
    And request servicePointEntityRequest
    When method POST
    Then status 201

    * def servicePointEntityRequest1 = read('classpath:volaris/mod-dcb/eureka-features/samples/service-point/service-point-entity-request.json')
    * servicePointEntityRequest1.id = servicePointId11
    * servicePointEntityRequest1.name = servicePointName11
    * servicePointEntityRequest1.code = servicePointCode11

    Given path 'service-points'
    And request servicePointEntityRequest1
    When method POST
    Then status 201

    * def servicePointEntityRequest2 = read('classpath:volaris/mod-dcb/eureka-features/samples/service-point/service-point-entity-request.json')
    * servicePointEntityRequest2.id = servicePointId21
    * servicePointEntityRequest2.name = servicePointName21
    * servicePointEntityRequest2.code = servicePointCode21

    Given path 'service-points'
    And request servicePointEntityRequest2
    When method POST
    Then status 201


  @PostLocation
  Scenario: Create Location
    * def locationUnitInstitutionEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/location/location-unit-institution-entity-request.json')
    * locationUnitInstitutionEntityRequest.id = karate.get('extInstitutionId', intInstitutionId)
    * locationUnitInstitutionEntityRequest.name = locationUnitInstitutionEntityRequest.name + ' ' + random_string()
    Given path 'location-units', 'institutions'
    And request locationUnitInstitutionEntityRequest
    When method POST
    Then status 201

    * def locationUnitCampusEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/location/location-unit-campus-entity-request.json')
    * locationUnitCampusEntityRequest.institutionId = karate.get('extInstitutionId', intInstitutionId)
    * locationUnitCampusEntityRequest.id = karate.get('extCampusId', intCampusId)
    * locationUnitCampusEntityRequest.name = locationUnitCampusEntityRequest.name + ' ' + random_string()
    * locationUnitCampusEntityRequest.code = locationUnitCampusEntityRequest.code + ' ' + random_string()
    Given path 'location-units', 'campuses'
    And request locationUnitCampusEntityRequest
    When method POST
    Then status 201

    * def locationUnitLibraryEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/location/location-unit-library-entity-request.json')
    * locationUnitLibraryEntityRequest.id = karate.get('extLibraryId', intLibraryId)
    * locationUnitLibraryEntityRequest.campusId = karate.get('extCampusId', intCampusId)
    * locationUnitLibraryEntityRequest.name = locationUnitLibraryEntityRequest.name + ' ' + random_string()
    * locationUnitLibraryEntityRequest.code = locationUnitLibraryEntityRequest.code + ' ' + random_string()
    Given path 'location-units', 'libraries'
    And request locationUnitLibraryEntityRequest
    When method POST
    Then status 201

    * def locationEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/location/location-entity-request.json')
    * locationEntityRequest.id = karate.get('extLocationId', locationId)
    * locationEntityRequest.institutionId = karate.get('extInstitutionId', intInstitutionId)
    * locationEntityRequest.campusId = karate.get('extCampusId', intCampusId)
    * locationEntityRequest.libraryId = karate.get('extLibraryId', intLibraryId)
   # * locationEntityRequest.primaryServicePoint = karate.get('extServicePointId', servicePointId)
   # * locationEntityRequest.servicePointIds = [karate.get('extServicePointId', servicePointId)]
    * locationEntityRequest.name = locationEntityRequest.name + ' ' + random_string()
    * locationEntityRequest.code = locationEntityRequest.code + ' ' + random_string()
    Given path 'locations'
    And request locationEntityRequest
    When method POST
    Then status 201

  @PostHoldings
  Scenario: Create Holdings
    * def holdingsEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/holdings/holdings-entity-request.json')
    * holdingsEntityRequest.id = karate.get('extHoldingsRecordId', holdingId)
    * holdingsEntityRequest.instanceId = karate.get('extInstanceId', instanceId)
    * holdingsEntityRequest.permanentLocationId = karate.get('extLocationId', locationId)

    Given path 'holdings-sources/'
    And headers headersUser
    And param query = 'name==FOLIO'
    When method GET
    Then status 200

    * holdingsEntityRequest.sourceId = response.holdingsRecordsSources[0].id

    Given path 'holdings-storage', 'holdings'
    And request holdingsEntityRequest
    When method POST
    Then status 201

  @PostMaterialType
  Scenario: create material type
    * def materialTypeEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/item/material-type-entity-request.json')
    * materialTypeEntityRequest.id = karate.get('extMaterialTypeId', intMaterialTypeId)
    * materialTypeEntityRequest.name = karate.get('extMaterialTypeName', materialTypeName)
    Given path 'material-types'
    And request materialTypeEntityRequest
    When method POST
    Then status 201

  @PostItem
  Scenario: Create Items
    * def permanentLoanTypeEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/item/permanent-loan-type-entity-request.json')
    * permanentLoanTypeEntityRequest.name = permanentLoanTypeEntityRequest.name + ' ' + random_string()
    Given path 'loan-types'
    And request permanentLoanTypeEntityRequest
    When method POST
    Then status 201

    * def itemEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/item/item-entity-request.json')
    * itemEntityRequest.barcode = itemBarcode
    * itemEntityRequest.id = karate.get('extItemId', intItemId)
    * itemEntityRequest.holdingsRecordId = karate.get('extHoldingsRecordId', holdingId)
    * itemEntityRequest.materialType.id = karate.get('extMaterialTypeId', intMaterialTypeId)
    * itemEntityRequest.status.name = karate.get('extStatusName', intStatusName)

    Given path 'inventory', 'items'
    And request itemEntityRequest
    When method POST
    Then status 201

    * def itemEntityRequest1 = read('classpath:volaris/mod-dcb/eureka-features/samples/item/item-entity-request.json')
    * itemEntityRequest1.barcode = itemBarcode1
    * itemEntityRequest1.id = karate.get('extItemId1', intItemId1)
    * itemEntityRequest1.holdingsRecordId = karate.get('extHoldingsRecordId', holdingId)
    * itemEntityRequest1.materialType.id = karate.get('extMaterialTypeId', intMaterialTypeId)
    * itemEntityRequest1.status.name = karate.get('extStatusName', intStatusName)

    Given path 'inventory', 'items'
    And request itemEntityRequest1
    When method POST
    Then status 201

    * def itemEntityRequest2 = read('classpath:volaris/mod-dcb/eureka-features/samples/item/item-entity-request.json')
    * itemEntityRequest2.barcode = itemBarcode2
    * itemEntityRequest2.id = karate.get('extItemId2', intItemId2)
    * itemEntityRequest2.holdingsRecordId = karate.get('extHoldingsRecordId', holdingId)
    * itemEntityRequest2.materialType.id = karate.get('extMaterialTypeId', intMaterialTypeId)
    * itemEntityRequest2.status.name = karate.get('extStatusName', intStatusName)

    Given path 'inventory', 'items'
    And request itemEntityRequest2
    When method POST
    Then status 201

    * def itemEntityRequest3 = read('classpath:volaris/mod-dcb/eureka-features/samples/item/item-entity-request.json')
    * itemEntityRequest3.barcode = itemBarcode3
    * itemEntityRequest3.id = karate.get('extItemId3', intItemId3)
    * itemEntityRequest3.holdingsRecordId = karate.get('extHoldingsRecordId', holdingId)
    * itemEntityRequest3.materialType.id = karate.get('extMaterialTypeId', intMaterialTypeId)
    * itemEntityRequest3.status.name = karate.get('extStatusName', intStatusName)

    Given path 'inventory', 'items'
    And request itemEntityRequest3
    When method POST
    Then status 201

    * def itemEntityRequest4 = read('classpath:volaris/mod-dcb/eureka-features/samples/item/item-entity-request.json')
    * itemEntityRequest4.barcode = itemBarcode4
    * itemEntityRequest4.id = karate.get('extItemId4', intItemId4)
    * itemEntityRequest4.holdingsRecordId = karate.get('extHoldingsRecordId', holdingId)
    * itemEntityRequest4.materialType.id = karate.get('extMaterialTypeId', intMaterialTypeId)
    * itemEntityRequest4.status.name = karate.get('extStatusName', intStatusName)

    Given path 'inventory', 'items'
    And request itemEntityRequest4
    When method POST
    Then status 201

    * def itemEntityRequest5 = read('classpath:volaris/mod-dcb/eureka-features/samples/item/item-entity-request.json')
    * itemEntityRequest5.barcode = itemBarcode5
    * itemEntityRequest5.id = karate.get('extItemId5', intItemId4)
    * itemEntityRequest5.holdingsRecordId = karate.get('extHoldingsRecordId', holdingId)
    * itemEntityRequest5.materialType.id = karate.get('extMaterialTypeId', intMaterialTypeId)
    * itemEntityRequest5.status.name = karate.get('extStatusName', intStatusName)

    Given path 'inventory', 'items'
    And request itemEntityRequest5
    When method POST
    Then status 201

    * def itemEntityRequest6 = read('classpath:volaris/mod-dcb/eureka-features/samples/item/item-entity-request.json')
    * itemEntityRequest6.barcode = itemBarcode6
    * itemEntityRequest6.id = karate.get('extItemId6', intItemId6)
    * itemEntityRequest6.holdingsRecordId = karate.get('extHoldingsRecordId', holdingId)
    * itemEntityRequest6.materialType.id = karate.get('extMaterialTypeId', intMaterialTypeId)
    * itemEntityRequest6.status.name = karate.get('extStatusName', intStatusName)

    Given path 'inventory', 'items'
    And request itemEntityRequest6
    When method POST
    Then status 201

    * def itemEntityRequest7 = read('classpath:volaris/mod-dcb/eureka-features/samples/item/item-entity-request.json')
    * itemEntityRequest7.barcode = itemBarcode11
    * itemEntityRequest7.id = itemId11
    * itemEntityRequest7.holdingsRecordId = karate.get('extHoldingsRecordId', holdingId)
    * itemEntityRequest7.materialType.id = karate.get('extMaterialTypeId', intMaterialTypeId)
    * itemEntityRequest7.status.name = karate.get('extStatusName', intStatusName)

    Given path 'inventory', 'items'
    And request itemEntityRequest7
    When method POST
    Then status 201

    * def itemEntityRequest8 = read('classpath:volaris/mod-dcb/eureka-features/samples/item/item-entity-request.json')
    * itemEntityRequest8.barcode = itemBarcode51
    * itemEntityRequest8.id = itemId51
    * itemEntityRequest8.holdingsRecordId = karate.get('extHoldingsRecordId', holdingId)
    * itemEntityRequest8.materialType.id = karate.get('extMaterialTypeId', intMaterialTypeId)
    * itemEntityRequest8.status.name = karate.get('extStatusName', intStatusName)

    Given path 'inventory', 'items'
    And request itemEntityRequest8
    When method POST
    Then status 201

    * def itemEntityRequest9 = read('classpath:volaris/mod-dcb/eureka-features/samples/item/item-entity-request.json')
    * itemEntityRequest9.barcode = itemBarcode61
    * itemEntityRequest9.id = itemId61
    * itemEntityRequest9.holdingsRecordId = karate.get('extHoldingsRecordId', holdingId)
    * itemEntityRequest9.materialType.id = karate.get('extMaterialTypeId', intMaterialTypeId)
    * itemEntityRequest9.status.name = karate.get('extStatusName', intStatusName)

    Given path 'inventory', 'items'
    And request itemEntityRequest9
    When method POST
    Then status 201

    * def itemEntityRequest10 = read('classpath:volaris/mod-dcb/eureka-features/samples/item/item-entity-request.json')
    * itemEntityRequest10.barcode = itemBarcode71
    * itemEntityRequest10.id = itemId71
    * itemEntityRequest10.holdingsRecordId = karate.get('extHoldingsRecordId', holdingId)
    * itemEntityRequest10.materialType.id = karate.get('extMaterialTypeId', intMaterialTypeId)
    * itemEntityRequest10.status.name = karate.get('extStatusName', intStatusName)

    Given path 'inventory', 'items'
    And request itemEntityRequest10
    When method POST
    Then status 201

    * def itemEntityRequest11 = read('classpath:volaris/mod-dcb/eureka-features/samples/item/item-entity-request.json')
    * itemEntityRequest11.barcode = itemBarcode110
    * itemEntityRequest11.id = itemId110
    * itemEntityRequest11.holdingsRecordId = karate.get('extHoldingsRecordId', holdingId)
    * itemEntityRequest11.materialType.id = karate.get('extMaterialTypeId', intMaterialTypeId)
    * itemEntityRequest11.status.name = karate.get('extStatusName', intStatusName)

    Given path 'inventory', 'items'
    And request itemEntityRequest11
    When method POST
    Then status 201

    * def itemEntityRequest12 = read('classpath:volaris/mod-dcb/eureka-features/samples/item/item-entity-request.json')
    * itemEntityRequest12.barcode = itemBarcode112
    * itemEntityRequest12.id = itemId112
    * itemEntityRequest12.holdingsRecordId = karate.get('extHoldingsRecordId', holdingId)
    * itemEntityRequest12.materialType.id = karate.get('extMaterialTypeId', intMaterialTypeId)
    * itemEntityRequest12.status.name = karate.get('extStatusName', intStatusName)

    Given path 'inventory', 'items'
    And request itemEntityRequest12
    When method POST
    Then status 201

  @PostGroup
  Scenario: Create Groups
    * def groupEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/user/group-entity-request.json')
    * groupEntityRequest.id = karate.get('extUserGroupId', intUserGroupId)
    * groupEntityRequest.group = groupEntityRequest.group + ' ' + random_string()
    Given path 'groups'
    And request groupEntityRequest
    When method POST
    Then status 201

    * def groupEntityRequest1 = read('classpath:volaris/mod-dcb/eureka-features/samples/user/group-entity-request.json')
    * groupEntityRequest1.id = patronGroupId
    * groupEntityRequest1.group = patronGroupName
    Given path 'groups'
    And request groupEntityRequest1
    When method POST
    Then status 201

  Scenario: create Patron
    * def createPatronGroupRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/patron/create-patronGroup-request.json')
    Given path 'groups'
    And request createPatronGroupRequest
    When method POST
    Then status 201

  @PostUser
  Scenario: Create Users
    * def intUserId = '8b83f6b6-77b3-11ee-b962-0242ac120002'
    * def userEntityRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/user/user-entity-request.json')
    * userEntityRequest.barcode = extUserBarcode
    * userEntityRequest.patronGroup = karate.get('extGroupId', intUserGroupId)
    * userEntityRequest.id = karate.get('extUserId', intUserId)
    Given path 'users'
    And request userEntityRequest
    When method POST
    Then status 201

    * def intUserId1 = '8b83f6b6-77b3-11ee-b962-0242ac120003'
    * def userEntityRequest1 = read('classpath:volaris/mod-dcb/eureka-features/samples/user/user-entity-request.json')
    * userEntityRequest1.barcode = extUserBarcode1
    * userEntityRequest1.patronGroup = karate.get('extGroupId', intUserGroupId)
    * userEntityRequest1.id = karate.get('extUserId1', intUserId1)
    Given path 'users'
    And request userEntityRequest1
    When method POST
    Then status 201

    * def userEntityRequest2 = read('classpath:volaris/mod-dcb/eureka-features/samples/user/user-entity-request.json')
    * userEntityRequest2.id = patronId21
    * userEntityRequest2.barcode = patronBarcode21
    Given path 'users'
    And request userEntityRequest2
    When method POST
    Then status 201

    * def userEntityRequest3 = read('classpath:volaris/mod-dcb/eureka-features/samples/user/user-entity-request.json')
    * userEntityRequest3.id = patronId31
    * userEntityRequest3.barcode = patronBarcode31
    Given path 'users'
    And request userEntityRequest3
    When method POST
    Then status 201

    * def userEntityRequest5 = read('classpath:volaris/mod-dcb/eureka-features/samples/user/user-entity-request.json')
    * userEntityRequest5.id = patronId51
    * userEntityRequest5.barcode = patronBarcode51
    * userEntityRequest5.type = 'dcb'
    Given path 'users'
    And request userEntityRequest5
    When method POST
    Then status 201

    * def userEntityRequest6 = read('classpath:volaris/mod-dcb/eureka-features/samples/user/user-entity-request.json')
    * userEntityRequest6.id = patronId1
    * userEntityRequest6.barcode = patronBarcode1

    Given path 'users'
    And request userEntityRequest6
    When method POST
    Then status 201

    * def userEntityRequest7 = read('classpath:volaris/mod-dcb/eureka-features/samples/user/user-entity-request.json')
    * userEntityRequest7.id = patronId110
    * userEntityRequest7.barcode = patronBarcode110
    * userEntityRequest7.type = 'patron'

    Given path 'users'
    And request userEntityRequest7
    When method POST
    Then status 201

    * def userEntityRequest8 = read('classpath:volaris/mod-dcb/eureka-features/samples/user/user-entity-request.json')
    * userEntityRequest8.id = patronId2
    * userEntityRequest8.barcode = patronBarcode2

    Given path 'users'
    And request userEntityRequest8
    When method POST
    Then status 201

    * def userEntityRequest9 = read('classpath:volaris/mod-dcb/eureka-features/samples/user/user-entity-request.json')
    * userEntityRequest9.id = patronId111
    * userEntityRequest9.barcode = patronBarcode111
    * userEntityRequest9.type = 'patron'

    Given path 'users'
    And request userEntityRequest9
    When method POST
    Then status 201


  @CreateLoanPolicy
  Scenario: Create loan policy
    Given path 'loan-policy-storage/loan-policies'
    And request
    """
    {
    "id": "d9cd0bed-1b49-4b5e-a7bd-064b8d177231",
    "name": "loanPolicyName",
    "loanable": true,
    "loansPolicy": {
        "profileId": "Rolling",
        "period": {
            "duration": 1,
            "intervalId": "Hours"
        },
        "closedLibraryDueDateManagementId": "CURRENT_DUE_DATE_TIME"
    },
    "renewable": true,
    "renewalsPolicy": {
        "unlimited": false,
        "numberAllowed": 3.0,
        "renewFromId": "SYSTEM_DATE",
        "differentPeriod": false
    }
    }
    """
    When method POST

  @CreateRequestPolicy
  Scenario: Create request policy
    Given path 'request-policy-storage/request-policies'
    And request
    """
    {
    "id": "d9cd0bed-1b49-4b5e-a7bd-064b8d177231",
    "name": "requestPolicyName",
    "description": "Allow all request types",
    "requestTypes": [
        "Hold",
        "Page",
        "Recall"
    ]
    }
    """
    When method POST
  @CreateNoticePolicy
  Scenario: Create notice policy
    Given path 'patron-notice-policy-storage/patron-notice-policies'
    And request
    """
    {
    "id": "122b3d2b-4788-4f1e-9117-56daa91cb75c",
    "name": "patronNoticePolicyName",
    "description": "A basic notice policy that does not define any notices",
    "active": true,
    "loanNotices": [],
    "feeFineNotices": [],
    "requestNotices": []
    }
    """
    When method POST

  @CreateOverdueFinePolicy
  Scenario: Create overdue fine policy
    Given path 'overdue-fines-policies'
    And request
    """
    {
    "name": "overdueFinePolicyName",
    "description": "Test overdue fine policy",
    "countClosed": true,
    "maxOverdueFine": 0.0,
    "forgiveOverdueFine": true,
    "gracePeriodRecall": true,
    "maxOverdueRecallFine": 0.0,
    "id": "cd3f6cac-fa17-4079-9fae-2fb28e521412"
    }
    """
    When method POST

  @CreateLostItemFeesPolicy
  Scenario: Create lost item fees policy
    Given path 'lost-item-fees-policies'
    And request
    """
    {
    "name": "lostItemFeesPolicyName",
    "description": "Test lost item fee policy",
    "chargeAmountItem": {
        "chargeType": "actualCost",
        "amount": 0.0
    },
    "lostItemProcessingFee": 0.0,
    "chargeAmountItemPatron": true,
    "chargeAmountItemSystem": true,
    "lostItemChargeFeeFine": {
        "duration": 2,
        "intervalId": "Days"
    },
    "returnedLostItemProcessingFee": true,
    "replacedLostItemProcessingFee": true,
    "replacementProcessingFee": 0.0,
    "replacementAllowed": true,
    "lostItemReturned": "Charge",
    "id": "ed892c0e-52e0-4cd9-8133-c0ef07b4a709"
    }
    """
    When method POST

  @CirculationRules
  Scenario: Update circulation rules
    Given path 'circulation/rules'
    And request
    """
    {
    "id": "1721f01b-e69d-5c4c-5df2-523428a04c55",
    "rulesAsText": "priority: t, s, c, b, a, m, g\nfallback-policy: l d9cd0bed-1b49-4b5e-a7bd-064b8d177231 r d9cd0bed-1b49-4b5e-a7bd-064b8d177231 n 122b3d2b-4788-4f1e-9117-56daa91cb75c o cd3f6cac-fa17-4079-9fae-2fb28e521412 i ed892c0e-52e0-4cd9-8133-c0ef07b4a709 \nm 1a54b431-2e4f-452d-9cae-9cee66c9a892: l d9cd0bed-1b49-4b5e-a7bd-064b8d177231 r d9cd0bed-1b49-4b5e-a7bd-064b8d177231 n 122b3d2b-4788-4f1e-9117-56daa91cb75c o cd3f6cac-fa17-4079-9fae-2fb28e521412 i ed892c0e-52e0-4cd9-8133-c0ef07b4a709"
    }
    """
    When method PUT

  @PostCancellationReason
  Scenario: create a cancellation reason
    * def cancellationReasonRequest = read('classpath:volaris/mod-dcb/eureka-features/samples/request/cancellation-reason-entity-request.json')
    * cancellationReasonRequest.id = karate.get('extCancellationReasonId', cancellationReasonId)
    Given path 'cancellation-reason-storage', 'cancellation-reasons'
    And request cancellationReasonRequest
    When method POST
    Then status 201




